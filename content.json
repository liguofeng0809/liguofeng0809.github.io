{"meta":{"title":1024,"subtitle":"与你，与我","description":"只有时时刻刻为将要到来的机会做准备，才不会错过那一次次的机会……","author":"feng","url":"http://example.com","root":"/"},"pages":[{"title":"About","date":"2021-10-08T16:00:00.000Z","updated":"2021-12-03T09:44:03.618Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"武汉商学院 机器人工程专业 练习生一枚 IT 🐶 &amp; 半个Program 🐵 熟悉Java服务器端开发的知识 对分布式和微服务方向很感兴趣 经常参加有氧运动 喜欢看一些拓展思维的电影"},{"title":"categories","date":"2021-10-09T17:16:47.000Z","updated":"2021-10-09T17:17:37.741Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"weixin","date":"2021-10-09T09:33:03.000Z","updated":"2021-10-09T09:39:54.004Z","comments":true,"path":"weixin/index.html","permalink":"http://example.com/weixin/index.html","excerpt":"","text":"![](C:\\Users\\11419\\Desktop\\Study BOKE\\program\\blog\\source\\weixin\\111.jpg)"},{"title":"tags","date":"2021-10-09T12:35:25.000Z","updated":"2021-10-09T12:36:54.946Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的学习记录day01","date":"2021-10-06T05:49:46.000Z","updated":"2021-10-06T05:56:30.235Z","comments":true,"path":"我的学习记录day01/index.html","permalink":"http://example.com/%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95day01/index.html","excerpt":"","text":"HashMap集合嵌套ArrayList集合(如有侵权，请联系qq:1141973834 删除，此仅记录每天所学内容) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.Set;/** * @program: javalearnCode * @description: HashMap集合嵌套ArrayList集合。 * @author: chen * @create: 2018-09-03 11:34 **/ public class HashMapArrayListDemo &#123; public static void main(String[] args)&#123; /* 假设HashMap有3个集合是ArrayList： 三国演义 诸葛亮 周瑜 红楼梦 黛玉 宝玉 西游记 悟空 唐僧 */ //创建集合 HashMap&lt;String, ArrayList&lt;String&gt;&gt; novels= new HashMap&lt;String, ArrayList&lt;String&gt;&gt;(); ArrayList&lt;String&gt; sanGuoCharacters= new ArrayList&lt;String&gt;(); sanGuoCharacters.add(&quot;诸葛亮&quot;); sanGuoCharacters.add(&quot;周瑜&quot;); ArrayList&lt;String&gt; xiyoujiCharacters= new ArrayList&lt;String&gt;(); xiyoujiCharacters.add(&quot;悟空&quot;); xiyoujiCharacters.add(&quot;唐僧&quot;); ArrayList&lt;String&gt; hongloumengCharacters= new ArrayList&lt;String&gt;(); hongloumengCharacters.add(&quot;黛玉&quot;); hongloumengCharacters.add(&quot;宝玉&quot;); novels.put(&quot;三国演义&quot;, sanGuoCharacters); novels.put(&quot;西游记&quot;, xiyoujiCharacters); novels.put(&quot;红楼梦&quot;, hongloumengCharacters); //遍历 Set&lt;String&gt; keys= novels.keySet(); for(String key: keys)&#123; System.out.println(key); ArrayList&lt;String&gt; characters=novels.get(key); //遍历集合，List特有的遍历方式size()和get()结合 for(int i=0; i&lt;characters.size(); ++i)&#123; String character= characters.get(i); System.out.println(&#x27;\\t&#x27;+character); &#125; // 增强for遍历集合 // for(String character: characters)&#123; // System.out.println(character); // &#125;// 迭代器遍历集合// Iterator&lt;String&gt; it= characters.iterator();// while(it.hasNext())&#123;// String character= it.next();// System.out.println(character);// &#125; &#125; &#125;&#125; ArrayList集合嵌套HashMap集合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.ArrayList;import java.util.HashMap;import java.util.Set;/** * @program: javalearnCode * @description: ArrayList集合嵌套HashMap * @author: chen * @create: 2018-09-03 16:29 **/public class ArraListHashMapDemo &#123; public static void main(String[] args)&#123; //假设ArrayList有3个集合是HashMap /* 吕布-貂蝉 周瑜-小乔 --------------- 牛魔王-铁扇公主 玉帝-王母 --------------- 贾琏-王熙凤 贾宝玉-薛宝钗 --------------- */ //创建集合 ArrayList&lt;HashMap&lt;String, String&gt;&gt; array= new ArrayList&lt;HashMap&lt;String, String&gt;&gt;(); HashMap&lt;String, String&gt; sanguoCouples= new HashMap&lt;String, String&gt;(); sanguoCouples.put(&quot;周瑜&quot;,&quot;小乔&quot;); sanguoCouples.put(&quot;吕布&quot;,&quot;貂蝉&quot;); HashMap&lt;String,String&gt; xiyoujiCouples= new HashMap&lt;String, String&gt;(); xiyoujiCouples.put(&quot;牛魔王&quot;,&quot;铁扇公主&quot;); xiyoujiCouples.put(&quot;玉帝&quot;,&quot;王母&quot;); HashMap&lt;String, String&gt; hongloumengCouples= new HashMap&lt;String, String&gt;(); hongloumengCouples.put(&quot;贾琏&quot;,&quot;王熙凤&quot;); hongloumengCouples.put(&quot;贾宝玉&quot;,&quot;薛宝钗&quot;); array.add(sanguoCouples); array.add(xiyoujiCouples); array.add(hongloumengCouples); //遍历集合 //获取ArrayList集合中每个HashMap元素 for(HashMap&lt;String, String&gt; couples: array)&#123; //先获取所有键 Set&lt;String&gt; husbands=couples.keySet(); for(String husband: husbands)&#123; //根据键获取值 String wife= couples.get(husband); System.out.println(husband+&quot;-&quot;+wife); &#125; System.out.println(&quot;---------------&quot;); &#125; &#125;&#125;"}],"posts":[{"title":"Redis","slug":"Redis","date":"2022-03-28T16:00:00.000Z","updated":"2022-04-04T15:07:31.384Z","comments":true,"path":"2022/03/29/Redis/","link":"","permalink":"http://example.com/2022/03/29/Redis/","excerpt":"","text":"Redis学习笔记1.Redis的安装 下载安装包 将本地安装包上传到服务器（Linux） 安装gcc的C语言编译环境 解压服务器端的Redis压缩包 编译解压后的文件 安装编译后的文件 1.首先在官网下载redis 的安装包（linux系统的安装包）Download | Redis 2.将Linux压缩包传到Linux系统中1234上传命令：scp /redis/redis-6.2.6.tar.gz root@119.91.204.71:/redis/// /redis/redis-6.2.6.tar.gz --本地安装包目录// /redis/ --需要传到的Linux系统目录// root@119.91.204.71: --服务器用户名@服务器地址 出现错误：Permission denied, please try again. 出现原因：上传的文件夹没有权限 解决方法：chmod 776 /redis/ –开放文件夹的读写权限 Linux实用命令：Linux常用实用命令-格姗知识圈 (geshanzsq.com) 123456789101112131415Linux 下的每个文件都有以下三种权限r：表示读取，对应的数字为 4；w：表示写入，对应的数字为 2；x：表示执行，对应的数字为 1通过 4、2、1 的组合，我们可以得到以下几种权限0：没有权限，用 - 表示4：读取权限，用 w 表示5：读取和执行权限，用 rx 表示6：读取和写入权限，用 rw 表示7：读取、写入和执行权限，用 rwx 表示 3.安装gcc的C语言编译环境1234//安装gccinstall gcc//查看版本号gcc --version 4.解压压缩包1tar -zxvf redis-6.2.6.tar.gz 5.编译解压后的文件==这一步只是编译了文件，并没有进行安装== 1234//进入解压后的文件目录redis-6.2.6cd redis-6.2.6//编译make 可能报错: 解决方法：make distclean 后重新编译 6.安装编译后的redis文件123456//安装redismake install//查看安装的文件（一般会安装在 /usr/local/bin）cd /usr/local/bin//查看ls||ll 7.启动redis 前台启动（不推荐） ==需要在bin目录下执行== 1redis-server 后台启动（推荐） 1.复制 redis-6.2.6目录下的redis.conf文件 12//复制 redis.conf文件到copy_redis目录下取名redis.confcp redis.conf /copy_redis/redis.conf 2.使用vi编辑器修改指令 123456789//进入copy——redis的文件夹cd /copy_redis//使用vi编辑器进入redis.confvi redis.conf--&gt; 命令模式下使用 /daemonize寻找关键字--&gt; 按a进入insert模式--&gt; 将daemonize no ---&gt; daemonize yes--&gt; 按ESC退出编辑模式--&gt; 输入 :wq 保存并退出 3.启动后台redis 与关闭 12345678910//进入/usr/local/bin目录cd /usr/local/bin//启动redisredis-server /copy_redis/redis.conf//查看redis进程ps -ef | grep redis//访问redisredis-cli//关闭redisredis-cli shutdown || kill -9 进程号（如图） || redis-cli -p63 2.redis.conf配置文件的修改1234// 修改/copy_redis中的redis.confcd /copy_redis// 使用vi编辑器进入redis.confvi redis.conf ==注销 bind 127.0.0.1 -::1== 不改只能本地访问 ==将protected-mode yes —&gt; protected-mode no== 改成no支持远程访问 修改密码 1234//找到如下内容#requirepass foobared//去掉注释或另起一行；设置密码requirepass 123456qq 验证密码 12345678910111213141516171. 启动： ./redis-server redis.conf 2. 进入客户端： ./redis-cli 3. 输入config get requirepass验证4. 出现“(error) NOAUTH Authentication required.证明设置密码成功！5. 输入密码： auth 123456qq 得到ok6. 再次输入config get requirepass验证，即可看到自己设置的密码，123456就是密码 1) &quot;requirepass&quot; 2) &quot;123456qq&quot; 3.Jedis操作Redis 注释redis.conf中的bind 127.0.0.1 //不注释只能本地访问 将protected-mode yes —&gt; protected-mode no //开启远程的访问 关闭防火墙或者开启安全组的端口端口权限 123456789101112131415161、开启防火墙 systemctl start firewalld2、查看防火墙状态systemctl status firewalld3、关闭防火墙 systemctl stop firewalld4、开放指定端口firewall-cmd --zone=public --add-port=1935/tcp --permanent命令含义：--zone #作用域--add-port=1935/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效5、查看端口号netstat -ntlp //查看当前所有tcp端口·netstat -ntulp |grep 1935 //查看所有1935端口使用情况·","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"MySQL基础","slug":"MySQL基础","date":"2022-03-18T16:00:00.000Z","updated":"2022-03-21T08:21:33.128Z","comments":true,"path":"2022/03/19/MySQL基础/","link":"","permalink":"http://example.com/2022/03/19/MySQL%E5%9F%BA%E7%A1%80/","excerpt":"","text":"01、什么是数据库，为什么要学习数据库javaEE：企业级java开发 Web 前端（页面：展示，数据！） 后台（连接点：连接数据库JDBC，连接前端（控制，控制视图跳转，和给前端传递数据）） 数据库（存数据） 1.为什么学习数据库 岗位需求 现在的世界，大数据时代，得数据者得天下 被迫需求：存数据 数据库是所有软件体系中最核心的存在 2.什么是数据库数据库（DB,database） 概念：数据仓库，软件，安装在操作系统(window,linux,mac…)之上。SQL，可以存储大量的数据，500w！ 作用：存储数据，管理数据 02、初始MySQL，关系型和非关系型数据库区别1.数据库分类关系型数据库：(SQL) MySQL、oracle、SqlServer、DB2、SQLLITE 通过表和表之间，行和列之间的关系进行数据的存储。 非关系型数据库：(NoSQL) not only Redis、mongdb 非关系型数据库，对象存储，通过对象的自身的属性来决定。 DBMS(数据库管理系统) 数据库的管理软件，科学有效的管理我们的数据，维护和获取数据 MySQL，数据库管理系统 2.MySQL简介MySQL是一个**关系型数据库管理系统** 前世：瑞典MySQL AB 公司开发 今生：属于 Oracle 旗下产品 MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 开源的数据库软件 体积小、速度快、总体拥有成本低，招人成本比较低，所以人必须会用~ 中小型网站，或者大型网站，集群！ 官网：MySQL 安装建议： 尽量不要使用exe，注册表 尽可能使用压缩包安装~ 03、安装MySQL详细说明1.安装步骤 解压 mysql-5.7.34-winx64.zip 把这个包放到自己的电脑环境目录下 配置环境变量 修改系统变量Path即可 新建mysql配置文件ini 123456789[mysqld]# 设置mysql的安装目录basedir=D:\\\\environment\\\\mysql-5.7.34-winx64# 设置mysql数据库的数据的存放目录datadir=D:\\\\environment\\\\mysql-5.7.34-winx64\\\\data# 设置3306端口port=3306# 跳过验证skip-grant-tables 启动管理员模式下的cmd，切换到mysql安装目录的bin目录 安装mysql服务 mysqld -install 初始化数据库文件 mysqld --initialize-insecure --user=mysql 这个时候安装目录就会多一个data目录 启动mysqlnet start mysql，然后用命令mysql -u root -p进入mysql管理界面(-p后面不要加空格) 进入界面后，修改密码（sql语句后面一定要加分号） 1update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;; 输入flush privileges;刷新权限 注释掉ini中的跳过密码skip-grant-tables 退出mysql命令行exit，停止mysql net stop mysql 然后启动服务，再次成功登陆，就ok了 2.安装遇到的问题 执行mysqld -install报错如下的话 可以先安装下面这个即可 Download Visual C++ Redistributable Packages for Visual Studio 2013 from Official Microsoft Download Center sc delete mysql 清空服务 04、sqlyog软件安装和使用 无脑安装 注册 打开连接数据库 界面 这里与之前data文件夹对应 新建一个数据库 school 查看历史记录可以查到对应如下语句： 1CREATE DATABASE `school`CHARACTER SET utf8 COLLATE utf8_general_ci; ==每一个sqlyog的执行操作，本质就是对应了一个sql,可以在软件的历史记录中查看== 新建一张表student（id，姓名，年龄） 查看表 自己尝试添加多条记录 05、基本的命令行操作1234567891011121314151617181920212223242526mysql -uroot -p123456 -- 连接数据库update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;; -- 修改用户密码flush privileges; -- 刷新权限------------------------------ 所有的语句都使用;结尾show databases; -- 查看所有的数据库mysql&gt; use school; -- 切换数据库 use 数据库名Database changedmysql&gt; show tables; -- 显示数据库中所有表的信息mysql&gt; describe student; -- 显示表的详细信息create database weston; -- 创建一个数据库（这里过于简洁，后面详细介绍）exit -- 退出连接-- 单行注释/**多行注释*/ DDL 数据库定义语言 DML 数据库操作语言 DQL 数据库查询语言 DCL 数据库控制语言 06、操作数据库语句操作数据库 》 操作数据库中表 》操作数据库中表的数据 ==mysql关键字不区分大小写== 1.操作数据库（了解） 创建数据库 1CREATE DATABASE [IF NOT EXISTS] student; 删除数据库 1DROP DATABASE [IF EXISTS] zyy; 使用数据库 12-- 如果你的表名或者字段名是一个特殊字符，就需要带上``USER `student`; 查看数据库 1SHOW DATABASES; -- 查看所有的数据库 学习思路 ==对比sqlyog的可视化操作== 固定的语法或者关键字必须强行记住！ 07、列的数据类型讲解 数值 tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小的数据 3个字节 int 标准的整数 4个字节 bigint 较大的数据 8个字节 float 浮点数 4个字节 double 浮点数 8个字节 decimal 字符串形式的浮点数 （金融计算的时候，一般是使用decimal） 字符串 char 字符串固定大小的 0~255 varchar 可变字符串 0~65535 （常量的变量 String） tinytext 微型文本 2^8 -1 text 文件串 2^16 -1 (保存大文本) 时间日期 date YYYY-MM-DD 日期格式 time HH:mm:ss 时间格式 datetime YYYY-MM-DD HH:mm:ss 最常用的时间格式 timestamp 时间戳，1970.1.1到现在的毫秒数！较为常用！ year 年份表示 null 没有值，未知 ==注意：不要使用NULL进行运算，结果为NULL== 08、数据库的字段属性(重点)Unsigned: 无符号的整数 声明了该列不能声明为负数 Zerofill: 0填充的 不足的位数，使用0来填充 int(3) 5 — 005 自增： 通用理解为自增，自动在上一条记录的基础上+1（默认） 通常用来设计唯一的主键，index，必须是整数类型 可以自定义设计主键自增的起始值和步长 非空 null/not null： not null，如果不给他赋值，就会报错 null，如果不给他赋值，默认就是null 默认： 设置默认的值 如果不赋值，就会存默认值 拓展： 12345678910/*每个表，都必须存在以下五个字段 未来做项目用的，表示一个记录存在的意义id 主键version 乐观锁is_delete 伪删除gmt_create 创建时间gmt_update 修改时间*/ 09、创建数据库表123456789101112131415161718-- 目标：创建一个school数据库-- 创建student学生表，使用sql创建-- 学号 姓名 性别 出生日期 家庭地址 email-- 注意点：使用英文() 表的名称和字段尽量使用``括起来-- AUTO_INCREMENT 自增-- 字符串使用单引号括起来-- 所有的语句后面加上英文逗号，最后一个不加-- PRIMARY KEY主键，一个表一般只有一个唯一的主键CREATE TABLE IF NOT EXISTS `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;, `name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;, `sex` VARCHAR(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;, `birthday` DATETIME NOT NULL COMMENT &#x27;出生日期&#x27;, `address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭地址&#x27;, `email` VARCHAR(30) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, PRIMARY KEY(`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8 格式 123456CREATE TABLE [IF NOT EXISTS] `表名` ( `字段名` 列类型[属性] [索引] [注释], `字段名` 列类型[属性] [索引] [注释], `字段名` 列类型[属性] [索引] [注释], ...)[表类型][字符集设置][注释] 常用命令： 1234SHOW CREATE DATABASE `school` ; -- 查看创建数据库的语句SHOW CREATE TABLE `student`; -- 查看student数据表的定义语句DESC `student`; -- 查看表的结构 10、MyIASM和InnoDB区别12345/*关于数据库引擎INNODB 默认使用MYISAM 早些年使用的*/ MYISAM INNODB 事务支持 不支持 支持 数据行锁定 不支持 支持 外键约束 不支持 支持 全文索引 支持 不支持 表空间的大小 较小 较大，约为MYISAM的2倍 常规使用操作： MYISAM 节约空间，速度较快 INNODB 安全性高，事务的处理，多表多用户操作 在物理空间存在的位置 所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库 本质还是文件的存储！ mysql引擎在物理文件上的区别 INNODB 在数据库表中只有一个*.frm文件，以及上级目录下的ibdata1文件 MYISAM 对应的文件 *.frm 表结构的定义文件 *.MYD 数据文件(data) *.MYI 索引文件 (index) 设置数据库表的字符集编码 1CHARSET=utf8 不设置的话，会是mysql默认的字符集编码（不支持中文） mysql的默认编码是Latin1,不支持中文 在my.ini中配置默认的编码 1character-set-server=utf8 11、修改和删除数据表字段 修改 123456789101112131415-- 修改表名 ALTER TABLE `原表名` RENAME AS `新表名`;ALTER TABLE `teacher` RENAME AS `teacher1`;-- 新增表的字段 ALTER TABLE `表名` ADD 字段名 列属性ALTER TABLE `teacher1` ADD age INT(3);-- 修改表的字段（重命名，修改约束！）-- ALTER TABLE `表名` MODIFY 字段名 列属性; -- ALTER TABLE `表名` CHANGE 原字段名 现字段名 列属性;ALTER TABLE `teacher1` MODIFY age VARCHAR(3); -- 修改约束ALTER TABLE `teacher1` CHANGE age age1 INT(3);-- 字段重命名-- 删除表的字段ALTER TABLE `teacher1` DROP age1; 删除 12-- 删除表（如果存在再删除）DROP TABLE IF EXISTS teacher1; ==所有的创建和删除操作尽量加上判断，以免报错~== 注意点： ``字段，使用这个包裹 注释 – /**/ sql关键字大小写不敏感，建议大写写小写 所有的符号全部用英文 12、数据库级别的外键（了解） 方式一：创建表的时候，增加约束（麻烦，比较复杂） 12345678910111213141516171819202122232425-- 年级表CREATE TABLE `grade` ( `id` INT(30) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级id&#x27;, `name` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;, PRIMARY KEY (`id`))ENGINE=INNODB DEFAULT CHARSET=utf8-- 先删除之前的学生表DROP TABLE `student`;-- 学生表 id_grade 字段 需要引用年级表的 id字段-- 定义外键key-- 给这个外键添加约束（执行引用） references 引用CREATE TABLE IF NOT EXISTS `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;, `name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;, `sex` VARCHAR(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;, `birthday` DATETIME NOT NULL COMMENT &#x27;出生日期&#x27;, `address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭地址&#x27;, `email` VARCHAR(30) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `id_grade` INT(30) NOT NULL COMMENT &#x27;年级id&#x27;, PRIMARY KEY(`id`), KEY `fk_id_grade`(`id_grade`), CONSTRAINT `fk_id_grade` FOREIGN KEY (`id_grade`) REFERENCES `grade` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8 删除有外键关系的表的时候，必须要先删除引用别人的表（从表），再删除被引用的表（主表） 方式二：创建表成功后，添加外键约束 12345678910111213141516171819202122232425262728293031-- 年级表CREATE TABLE `grade` ( `id` INT(30) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级id&#x27;, `name` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;, PRIMARY KEY (`id`))ENGINE=INNODB DEFAULT CHARSET=utf8-- 学生表CREATE TABLE IF NOT EXISTS `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;, `name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;, `sex` VARCHAR(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;, `birthday` DATETIME NOT NULL COMMENT &#x27;出生日期&#x27;, `address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭地址&#x27;, `email` VARCHAR(30) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `id_grade` INT(30) NOT NULL COMMENT &#x27;年级id&#x27;, PRIMARY KEY(`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8-- DROP TABLE `grade`;-- DROP TABLE `student`;-- 创建表的时候没有外键关系ALTER TABLE `student` ADD CONSTRAINT `fk_id_grade` FOREIGN KEY (`id_grade`) REFERENCES `grade` (`id`);-- ALTER TABLE 表 ADD CONSTRAINT 约束名 FOREIGN KEY (作为外键的列) REFERENCES 哪个表 (哪个字段) 以上的操作都是物理外键，数据库级别的外键，我们不建议使用（避免数据库过多造成困扰！） 最佳实践 数据库就是单纯的表，只用来存数据，只有行(数据)和列（字段） 我们想使用多张表的数据，想使用外键（程序去实现） 13、insert语句详解数据库意义：数据存储，数据管理 DML语言：数据库操作语言 增 删 改 insert 123456789101112-- 插入语言-- INSERT INTO `表名`(`字段1`,`字段2`,`字段3`...) VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;...);INSERT INTO `grade`(`name`) VALUES(&#x27;大四&#x27;);INSERT INTO `student`(`name`,`birthday`,`id_grade`) VALUES(&#x27;张三&#x27;,&#x27;1995-11-20&#x27;,&#x27;1&#x27;);-- 一般写插入语句，我们一定要数据和字段一一对应。-- 插入多条-- INSERT INTO `表名`(`字段1`,`字段2`...) VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;...),(&#x27;值1&#x27;,&#x27;值2&#x27;...)...;INSERT INTO `grade`(`name`) VALUES(&#x27;大一&#x27;),(&#x27;大二&#x27;);INSERT INTO `student`(`name`,`birthday`,`id_grade`) VALUES(&#x27;李四&#x27;,&#x27;1994-11-20&#x27;,&#x27;2&#x27;),(&#x27;王五&#x27;,&#x27;1995-11-20&#x27;,&#x27;1&#x27;); 注意事项： 字段和字段之间使用逗号隔开 字段是可以省略，但是后面的值必须要一一对应，不能少 可以同时插入多条数据，VALUES后面的值，需要使用逗号分开VALUES(),()... 14、update语句详解 update 12345678-- 修改学员名字UPDATE `student` SET NAME=&#x27;zyy&#x27; WHERE id=&#x27;1&#x27;;-- 通过多个条件定位数据UPDATE `student` SET NAME=&#x27;hehe&#x27; WHERE NAME=&#x27;zyy&#x27; AND id_grade=&#x27;2&#x27;;-- 不指定条件的情况，会改动所有的表UPDATE `student` SET NAME=&#x27;all&#x27;;-- 语法-- UPDATE 表名 SET 列名=值[,列名=值,列名=值,列名=值...] [WHERE 条件] 条件：where 字句 运算符 id等于某个值，大于某个值，在某个区间内修改 操作符 含义 范围 结果 = 等于 5=6 false &lt;&gt; 或者 != 不等于 5!=6 true &gt; &lt; &gt;= &lt;= BETWEEN … AND … 某个范围内 BETWEEN 1 AND 3 [1,3] AND 和 &amp;&amp; 5&gt;1 and 1&gt;2 false OR 或 || 5&gt;1 or 1&gt;2 true 注意事项： 列尽量带上`` 条件，筛选的条件，如果没有指定，则会修改所有的列 value，可以是一个具体的值，也可以是一个变量 1UPDATE `student` SET birthday=CURRENT_TIME WHERE NAME=&#x27;hehe&#x27; AND id_grade=&#x27;2&#x27;; 多个设置的属性之间，使用英文逗号隔开（后面trim,可以干掉多余的逗号） 15、delete和truncate详解 delete 语法： delete from 表名 [where 条件] 1234-- 删除数据（避免这样写，会全部删除）DELETE FROM `student`;-- 删除指定数据DELETE FROM `student` WHERE id=1; truncate 作用：完全清空一个数据库表，标的结构和索引约束不会变！ 12-- 清空表TRUNCATE `student`; delete 和 truncate 区别 相同点：都能删除数据，都不会删除表结构 不同： truncate 重新设置自增列，计数器会归零 truncate 不会影响事务 123456789101112131415-- 测试 delete 和 truncate 区别CREATE TABLE `test`( `id` INT(4) NOT NULL AUTO_INCREMENT, `coll` VARCHAR(20) NOT NULL , PRIMARY KEY (`id`))ENGINE=INNODB DEFAULT CHARSET=utf8-- 不会影响自增DELETE FROM `test`;-- 自增归零TRUNCATE TABLE `test`;INSERT INTO `test` (`coll`) VALUES (&#x27;1&#x27;),(&#x27;2&#x27;),(&#x27;3&#x27;),(&#x27;4&#x27;); 了解即可delete 删除的问题,重启数据库,现象 innoDB 自增列会从1开始（存在内存当中的，断电即失） MyISAM 继续上一个自增量开始（存在文件中，不会丢失） 16、基本的select语句和别名使用（重点）DQL（data query language:数据查询语言） 所有的查询操作都用它 select 简单的查询，复杂的查询它都能做 数据库中最核心的语言，最重要的语句 使用频率最高的语句 select 语法 12345678910SELECT [ALL | DISTINCT]&#123;* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]&#125;FROM table_name [as table_alias] [left | right | inner join table_name2] -- 联合查询 [WHERE ...] -- 指定结果需满足的条件 [GROUP BY ...] -- 指定结果按照哪几个字段来分组 [HAVING] -- 过滤分组的记录必须满足的次要条件 [ORDER BY ...] -- 指定查询记录按一个或多个条件排序 [LIMIT &#123;[offset,]row_count | row_countOFFSET offset&#125;]; -- 指定查询的记录从哪条至哪条 注意：[]括号代表可选的，{}括号代表必选的 指定查询字段1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586DROP DATABASE IF EXISTS `school`;-- 创建一个school数据库CREATE DATABASE IF NOT EXISTS `school`;-- 使用school数据库USE `school`;-- 创建学生表DROP TABLE IF EXISTS `student`;CREATE TABLE `student`( `student_no` INT(4) NOT NULL COMMENT &#x27;学号&#x27;, `login_pwd` VARCHAR(20) DEFAULT NULL, `student_name` VARCHAR(20) DEFAULT NULL COMMENT &#x27;学生姓名&#x27;, `sex` TINYINT(1) DEFAULT NULL COMMENT &#x27;性别，0或1&#x27;, `grade_id` INT(11) DEFAULT NULL COMMENT &#x27;年级编号&#x27;, `phone` VARCHAR(50) NOT NULL COMMENT &#x27;联系电话&#x27;, `address` VARCHAR(255) NOT NULL COMMENT &#x27;地址&#x27;, `born_date` DATETIME DEFAULT NULL COMMENT &#x27;出生时间&#x27;, `email` VARCHAR (50) NOT NULL COMMENT &#x27;邮箱账号&#x27;, `identity_card` VARCHAR(18) DEFAULT NULL COMMENT &#x27;身份证号&#x27;, PRIMARY KEY (`student_no`))ENGINE=INNODB DEFAULT CHARSET=utf8;-- 创建年级表DROP TABLE IF EXISTS `grade`;CREATE TABLE `grade`( `grade_id` INT(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级编号&#x27;, `grade_name` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;, PRIMARY KEY (`grade_id`)) ENGINE=INNODB DEFAULT CHARSET = utf8;-- 创建科目表DROP TABLE IF EXISTS `subject`;CREATE TABLE `subject`( `subject_no`INT(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;课程编号&#x27;, `subject_name` VARCHAR(50) DEFAULT NULL COMMENT &#x27;课程名称&#x27;, `class_hour` INT(4) DEFAULT NULL COMMENT &#x27;学时&#x27;, `grade_id` INT(4) DEFAULT NULL COMMENT &#x27;年级编号&#x27;, PRIMARY KEY (`subject_no`))ENGINE = INNODB DEFAULT CHARSET = utf8;-- 创建成绩表DROP TABLE IF EXISTS `result`;CREATE TABLE `result`( `student_no` INT(4) NOT NULL COMMENT &#x27;学号&#x27;, `subject_no` INT(4) NOT NULL COMMENT &#x27;课程编号&#x27;, `exam_date` DATETIME NOT NULL COMMENT &#x27;考试日期&#x27;, `student_result` INT (4) NOT NULL COMMENT &#x27;考试成绩&#x27; )ENGINE = INNODB DEFAULT CHARSET = utf8; -- 插入学生数据 其余自行添加 这里只添加了2行INSERT INTO `student` (`student_no`,`login_pwd`,`student_name`,`sex`,`grade_id`,`phone`,`address`,`born_date`,`email`,`identity_card`)VALUES(1000,&#x27;123456&#x27;,&#x27;张伟&#x27;,0,2,&#x27;13800001234&#x27;,&#x27;北京朝阳&#x27;,&#x27;1980-1-1&#x27;,&#x27;text123@qq.com&#x27;,&#x27;123456198001011234&#x27;),(1001,&#x27;123456&#x27;,&#x27;赵强&#x27;,1,3,&#x27;13800002222&#x27;,&#x27;广东深圳&#x27;,&#x27;1990-1-1&#x27;,&#x27;text111@qq.com&#x27;,&#x27;123456199001011233&#x27;);-- 插入年级数据INSERT INTO `grade` (`grade_id`,`grade_name`) VALUES(1,&#x27;大一&#x27;),(2,&#x27;大二&#x27;),(3,&#x27;大三&#x27;),(4,&#x27;大四&#x27;),(5,&#x27;预科班&#x27;);-- 插入科目数据INSERT INTO `subject`(`subject_no`,`subject_name`,`class_hour`,`grade_id`)VALUES(1,&#x27;高等数学-1&#x27;,110,1),(2,&#x27;高等数学-2&#x27;,110,2),(3,&#x27;高等数学-3&#x27;,100,3),(4,&#x27;高等数学-4&#x27;,130,4),(5,&#x27;C语言-1&#x27;,110,1),(6,&#x27;C语言-2&#x27;,110,2),(7,&#x27;C语言-3&#x27;,100,3),(8,&#x27;C语言-4&#x27;,130,4),(9,&#x27;Java程序设计-1&#x27;,110,1),(10,&#x27;Java程序设计-2&#x27;,110,2),(11,&#x27;Java程序设计-3&#x27;,100,3),(12,&#x27;Java程序设计-4&#x27;,130,4),(13,&#x27;数据库结构-1&#x27;,110,1),(14,&#x27;数据库结构-2&#x27;,110,2),(15,&#x27;数据库结构-3&#x27;,100,3),(16,&#x27;数据库结构-4&#x27;,130,4),(17,&#x27;C#基础&#x27;,130,1);-- 插入成绩数据 这里仅插入了一组，其余自行添加INSERT INTO `result`(`student_no`,`subject_no`,`exam_date`,`student_result`)VALUES(1000,1,&#x27;2013-11-11 16:00:00&#x27;,85),(1000,2,&#x27;2013-11-12 16:00:00&#x27;,70),(1000,3,&#x27;2013-11-11 09:00:00&#x27;,68),(1000,4,&#x27;2013-11-13 16:00:00&#x27;,98),(1000,5,&#x27;2013-11-14 16:00:00&#x27;,58); 123456789101112-- 查询全部的学生 SELECT 字段 FROM 表名;SELECT * FROM student;-- 查询指定字段SELECT student_name, student_no FROM student;-- 别名，给结果起一个名字 AS 可以给字段起别名，也可以给表起别名SELECT student_name AS &#x27;学号&#x27;, student_no AS &#x27;姓名&#x27; FROM student;-- 函数 concat(a,b)SELECT CONCAT(&#x27;姓名：&#x27;, student_no) AS &#x27;新姓名&#x27; FROM student; 有的时候，列表名不是那么见名知意，我们可以起别名 17、去重及数据库的表达式 去重 distinct 123456-- 查询全部的考试成绩SELECT * FROM result;-- 查询有哪些同学参加了考试SELECT `student_no` FROM result;-- 发现重复数据，去重SELECT DISTINCT `student_no` FROM result; 数据库的列（表达式） 123456789-- 查询系统版本（函数） SELECT VERSION(); -- 用来计算（表达式） SELECT 100*3 -1 ; -- 查询自增的步长（变量） SELECT @@auto_increment_increment; -- 学员考试成绩 +1 查看 SELECT `student_no`,`student_result` + 1 AS &#x27;提分后&#x27; FROM result; 数据库中的表达式： 文本值，列，Null，函数，计算表达式，系统变量 select 表达式 from 表名 18、where子句之逻辑运算符作用：检索数据中符合条件的值 搜索的条件由一个或者多个表达式组成，结果布尔值 逻辑运算符 运算符 语法 描述 and &amp;&amp; a and b a&amp;&amp;b 逻辑与 or || a orb a||b 逻辑或 not ! not a !a 逻辑非 ==尽量适应英文字母== 12345678910111213141516171819202122-- 查询考试成绩在 95 ~ 100分之间SELECT student_no,student_result FROM result;-- andSELECT student_no,student_result FROM resultWHERE student_result&gt;95 AND student_result&lt;=100;-- &amp;&amp; SELECT student_no,student_result FROM resultWHERE student_result&gt;95 &amp;&amp; student_result&lt;=100;-- 模糊查询（区间）SELECT student_no,student_result FROM resultWHERE student_result BETWEEN 95 AND 100;-- 除了1000号学生之外的学生的成绩-- !=SELECT student_no,student_result FROM resultWHERE student_no != 1000;-- notSELECT student_no,student_result FROM resultWHERE NOT student_no = 1000; 19、模糊查询操作符详解 模糊查询：比较运算符 运算符 语法 描述 IS NULL a is null 如果操作符为null，结果为真 IS NOT NULL a is not null 如果操作符不为null，结果为真 BWTWEEN…AND… a between b and c 若a在b和c之间，则结果为真 LIKE a like b SQL匹配，如果a匹配b,则结果为真 IN a in (a1,a2,a3,…) 假设a在a1或者a2或者a3,…其中的某一个，则结果为真 123456789101112131415161718192021222324252627282930313233343536373839404142434445-- 查询姓刘的同学-- like 结合 -- %（代表0到任意个字符）-- _（代表1）-- 查询姓刘的同学SELECT `student_no`,`student_name` FROM `student`WHERE student_name LIKE &#x27;刘%&#x27;;-- 查询姓刘的同学，名字后面只有一个字的SELECT `student_no`,`student_name` FROM `student`WHERE student_name LIKE &#x27;刘_&#x27;;-- 查询姓刘的同学，名字后面有两个字的SELECT `student_no`,`student_name` FROM `student`WHERE student_name LIKE &#x27;刘__&#x27;;-- 查询名字中间有嘉字的同学SELECT `student_no`,`student_name` FROM `student`WHERE student_name LIKE &#x27;%%嘉%&#x27;;-- in (具体的一个或者多个值)-- 查询学号1001,1002,1003号学号SELECT `student_no`,`student_name` FROM `student`WHERE student_no IN (&#x27;1001&#x27;,&#x27;1002&#x27;,&#x27;1003&#x27;);-- 查询在北京的学生SELECT `student_no`,`student_name` FROM `student`WHERE address IN (&#x27;北京&#x27;);-- null-- 查询地址为空的学生SELECT `student_no`,`student_name` FROM `student`WHERE address = &#x27;&#x27; OR address IS NULL;-- not null-- 查询有出生日期的同学 不为空SELECT `student_no`,`student_name` FROM `student`WHERE born_date IS NOT NULL;-- 查询没有出生日期的同学 为空SELECT `student_no`,`student_name` FROM `student`WHERE born_date IS NULL; 20、联表查询join on详解 join 对比 七种join理论 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061-- =========连表查询==================-- 查询参加了考试的同学（学号，姓名，科目编号，分数）SELECT * FROM student;SELECT * FROM result;-- join on 连接查询-- where 等值查询-- inner joinSELECT st.`student_no`,st.`student_name`,re.`subject_no`,re.`student_result` FROM student AS stINNER JOIN result AS re ON st.`student_no`=re.`student_no`;-- right joinSELECT st.`student_no`,st.`student_name`,re.`subject_no`,re.`student_result` FROM student stRIGHT JOIN result re ON st.`student_no`=re.`student_no`;-- left joinSELECT st.`student_no`,st.`student_name`,re.`subject_no`,re.`student_result` FROM student stLEFT JOIN result re ON st.`student_no`=re.`student_no`;-- 查询缺考的同学SELECT st.`student_no`,st.`student_name`,re.`subject_no`,re.`student_result` FROM student stLEFT JOIN result re ON st.`student_no`=re.`student_no`WHERE re.`student_result` IS NULL;-- 查询了参加考试的同学信息（学号，学生姓名，科目名称，分数）SELECT stu.`student_no`,stu.`student_name`,sub.`subject_name`,res.`student_result`FROM `student` stuRIGHT JOIN `result` res ON res.`student_no`=stu.`student_no`INNER JOIN `subject` subON res.`subject_no`=sub.`subject_no`;-- 查询学员所属的年级（学号，学生的姓名，年级名称）SELECT `student_no`,`student_name`,`grade_name`FROM student stuINNER JOIN `grade` graON stu.`grade_id`=gra.`grade_id`;-- 查询了参加数据结构-1考试的同学信息（学号，学生姓名，科目名称，分数）SELECT stu.`student_no`,stu.`student_name`,sub.`subject_name`,res.`student_result`FROM student stuINNER JOIN `result` resON stu.`student_no` = res.`student_no`INNER JOIN `subject` subON res.`subject_no`=sub.`subject_no`WHERE sub.`subject_name`=&#x27;数据结构-1&#x27;;-- 我要查询哪些数据 select ...-- 从哪几个表中查 from 表 XXX join 连接的表 on 交叉条件-- 假设存在一种多张表查询，慢慢来，先查询两张表然后再慢慢增加 操作 描述 inner join 如果表中至少有一个匹配，就返回行 left join 会从左边中返回所有的值，即使右表中没有匹配 right join 会从右边中返回所有的值，即使左表中没有匹配 21、自连接及联表查询 自连接 自己的表和自己的表连接，核心：==一张表拆为两张一样的表即可== 12345678910111213141516171819202122-- 创建表-- unsigned 无符号-- auto_increment=9 自增的起始值DROP TABLE IF EXISTS `category` ;CREATE TABLE `category` ( `category_id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#x27;主题id&#x27;, `pid` INT(10) NOT NULL COMMENT &#x27;父id&#x27;, `category_name` VARCHAR(50) NOT NULL COMMENT &#x27;主题名字&#x27;, PRIMARY KEY (`category_id`)) ENGINE=INNODB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;-- 插入值INSERT INTO `category`(`category_id`,`pid`,`category_name`)VALUES(&#x27;2&#x27;,&#x27;1&#x27;,&#x27;信息技术&#x27;),(&#x27;3&#x27;,&#x27;1&#x27;,&#x27;软件开发&#x27;),(&#x27;4&#x27;,&#x27;3&#x27;,&#x27;数据库&#x27;),(&#x27;5&#x27;,&#x27;1&#x27;,&#x27;美术设计&#x27;),(&#x27;6&#x27;,&#x27;3&#x27;,&#x27;web开发&#x27;),(&#x27;7&#x27;,&#x27;5&#x27;,&#x27;ps技术&#x27;),(&#x27;8&#x27;,&#x27;2&#x27;,&#x27;办公信息&#x27;);SELECT * FROM `category`; 父类 pid category_id category_name 1 2 信息技术 1 3 软件开发 1 5 美术设计 子类 pid category_id category_name 3 4 数据库 2 8 办公信息 3 6 web开发 5 7 ps技术 操作：查询父类对应的子类关系 父类 子类 信息技术 办公信息 软件开发 数据库 软件开发 web开发 美术设计 ps技术 1234-- 查询父子信息，把一张表看为两个一模一样的表SELECT a.`category_name` AS &#x27;父栏目&#x27;,b.`category_name` AS &#x27;子栏目&#x27;FROM `category` AS a, `category` AS bWHERE a.`category_id`=b.`pid`; 22、分页和排序 排序 1234567891011-- 排序： 升序 ASC 降序 DESC-- ORDER BY 通过那个字段排序，怎么排-- 查询的结果根据成绩降序 排序SELECT stu.`student_no`,stu.`student_name`,sub.`subject_name`,res.`student_result`FROM student stuINNER JOIN `result` resON stu.`student_no` = res.`student_no`INNER JOIN `subject` subON res.`subject_no`=sub.`subject_no`WHERE sub.`subject_name`=&#x27;数据结构-1&#x27;ORDER BY `student_result` DESC; 1234567891011121314151617181920212223242526272829303132333435363738-- 100w-- 为什么要分页-- 缓解数据库压力，给人更好的体验 瀑布流-- 分页，每页只显示五条数据-- 语法 ： limit 起始值，页面的大小-- 网页应用：当前，总的页数，每页大小-- LIMIT 0,5 1~5-- LIMIT 1,5 2~6-- LIMIT 6,5SELECT stu.`student_no`,stu.`student_name`,sub.`subject_name`,res.`student_result`FROM student stuINNER JOIN `result` resON stu.`student_no` = res.`student_no`INNER JOIN `subject` subON res.`subject_no`=sub.`subject_no`WHERE sub.`subject_name`=&#x27;数据结构-1&#x27;ORDER BY `student_result` DESCLIMIT 1,5;-- 第一页 limit 0,5 (1-1)*5-- 第二页 limit 5,5 (2-1)*5-- 第三页 limit 10,5 (3-1)*5-- 第N页 limit 10,5 (n-1)*pageSize,pageSize-- pageSize,页面大小-- (n-1)*pageSize，起始值-- n，当前页-- 总页数 = (数据总数%页面大小==0)? (数据总数/页面大小) : (数据总数/页面大小 + 1)-- 查询科目高等数学-2，课程成绩排名前十的学生，并且分数要大于60的学生信息（学号，姓名，课程名称，分数）SELECT stu.`student_no`,stu.`student_name`,sub.`subject_name`,res.`student_result`FROM student stuINNER JOIN `subject` subON stu.`grade_id`=sub.`grade_id`INNER JOIN `result` resON sub.`subject_no`=res.`subject_no`WHERE sub.`subject_name`=&#x27;高等数学-2&#x27;AND res.`student_result`&gt;60ORDER BY res.`student_result`LIMIT 0,10; 语法： limit (查询起始下标,页面大小) 23、子查询和嵌套查询where（这个值是计算出来的） 本质：在where语句中嵌套一个子查询语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657-- 1.查询数据库结构-1的所有考试结果（学号，科目名，成绩），降序排列-- 方式1：使用连接查询SELECT res.`student_no`,res.`subject_no`,res.`student_result`FROM `result` resINNER JOIN `subject` subON res.`subject_no`=sub.`subject_no`WHERE sub.`subject_name`=&#x27;高等数学-2&#x27;ORDER BY res.`student_result` DESC;-- 使用子查询(由里及外)SELECT res.`student_no`,res.`subject_no`,res.`student_result`FROM `result` resWHERE res.`subject_no` = ( SELECT sub.`subject_no` FROM `subject` sub WHERE sub.`subject_name`=&#x27;高等数学-2&#x27;)ORDER BY res.`student_result` DESC;-- 分数不小于80分的学生的学号和姓名SELECT DISTINCT stu.`student_no`,stu.`student_name`FROM student stuINNER JOIN result resON stu.`student_no`=res.`student_no`WHERE res.`student_result` &gt; 80;-- 在这个基础上增加一个科目，查询课程为高等数学-2，且分数不小于80分的学生的学号和姓名SELECT DISTINCT stu.`student_no`,stu.`student_name`FROM student stuINNER JOIN result resON stu.`student_no`=res.`student_no`WHERE res.`student_result` &gt; 80AND res.`subject_no`=(SELECT sub.`subject_no` FROM `subject` subWHERE sub.`subject_name`=&#x27;高等数学-2&#x27;);SELECT DISTINCT stu.`student_no`,stu.`student_name`FROM student stuINNER JOIN result resON stu.`student_no`=res.`student_no`INNER JOIN `subject` subON res.`subject_no`=sub.`subject_no`WHERE sub.`subject_name`=&#x27;高等数学-2&#x27;AND res.`student_result` &gt; 80;-- 再次改造（由里及外）SELECT DISTINCT `student_no`,`student_name` FROM student WHERE student_no IN ( SELECT student_no FROM result WHERE `student_result` &gt; 80 AND subject_no = ( SELECT subject_no FROM `subject` WHERE `subject_name`=&#x27;高等数学-2&#x27; )); 24、MySQL常用函数官网：参考手册 123456789101112131415161718192021222324252627282930313233343536SELECT ABS(-8); -- 绝对值SELECT CEILING(9.4) ;-- 向上取整SELECT FLOOR(9.4);-- 向下取整SELECT RAND(); -- 返回一个0~1之间的随机数SELECT SIGN(-10); -- 判断一个数的符号，0 返回0 负数返回-1 正数返回1-- 字符串函数SELECT CHAR_LENGTH(&#x27;哈哈&#x27;); -- 字符串长度SELECT CONCAT(&#x27;我&#x27;,&#x27;爱&#x27;,&#x27;你&#x27;); -- 拼接字符串SELECT INSERT(&#x27;我爱编程helloworld&#x27;,1,2,&#x27;超级热爱&#x27;); -- 插入，替换SELECT LOWER(&#x27;ZYY&#x27;); -- 小写字母SELECT UPPER(&#x27;zyy&#x27;); -- 大写字母SELECT INSTR(&#x27;zyy&#x27;,&#x27;y&#x27;); -- 返回第一次出现的子串的索引SELECT REPLACE(&#x27;坚持就能成功&#x27;,&#x27;坚持&#x27;,&#x27;努力&#x27;); -- 替换出现的指定字符串SELECT SUBSTR(&#x27;坚持就能成功&#x27;, 5, 2); -- 返回指定的子字符串（源字符串，截取的位置，截取的长度）SELECT REVERSE(&#x27;清晨我上马&#x27;); -- 反转-- 时间和日期函数（记住！）SELECT CURRENT_DATE(); -- 获取当前日期SELECT CURDATE(); -- 获取当前日期SELECT NOW(); -- 获取当前的时间SELECT LOCALTIME(); -- 获取本地时间SELECT SYSDATE(); -- 获取系统时间SELECT YEAR(NOW()); -- 年SELECT MONTH(NOW()); -- 月SELECT DAY(NOW()); -- 日SELECT HOUR(NOW()); -- 时SELECT MINUTE(NOW()); -- 分SELECT SECOND(NOW()); -- 秒-- 系统SELECT SYSTEM_USER();SELECT USER();SELECT VERSION(); 25、聚合函数及分组过滤 函数名称 描述 count() 计数 sum() 求和 avg() 平均值 max() 最大值 min() 最小值 1234567891011121314151617181920212223242526-- 聚合函数-- 都能统计 表中数据-- count(字段) 会忽略所有的null值(想查询一个表中有多少个记录，就使用这个count())SELECT COUNT(student_name) FROM student;-- COUNT(*) 不会忽略所有的null值 本质计算行数SELECT COUNT(*) FROM student;-- COUNT(1) 不会忽略所有的null值 本质计算行数SELECT COUNT(1) FROM student;SELECT SUM(student_result) AS &#x27;总和&#x27; FROM result;SELECT AVG(student_result) AS &#x27;平均分&#x27; FROM result;SELECT MAX(student_result) AS &#x27;最高分&#x27; FROM result;SELECT MIN(student_result) AS &#x27;最低分&#x27; FROM result;-- 查询不同课程的平均分，最高分，最低分SELECT sub.subject_name AS &#x27;课程&#x27;,AVG(res.student_result) AS &#x27;平均分&#x27;,MAX(res.student_result) AS &#x27;最高分&#x27;,MIN(res.student_result) AS &#x27;最低分&#x27;FROM result resINNER JOIN `subject` subON res.`subject_no`=sub.`subject_no`GROUP BY res.`subject_no`HAVING AVG(res.student_result) &gt;80; 26、拓展之数据库级别的md5加密什么是MD5? 主要增加算法复杂度和不可逆性。 MD5不可逆，具体的值的md5是一样的 MD5破解网站的原理，背后有一个字典，MD5加密后的值，加密前的值 12345678910111213141516171819202122232425262728CREATE TABLE `testmd5`( `id` INT(4) NOT NULL, `name` VARCHAR(20) NOT NULL, `pwd` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`))ENGINE=INNODB DEFAULT CHARSET=utf8;-- 明文密码INSERT INTO `testmd5`(`id`,`name`,`pwd`)VALUES(1,&#x27;张三&#x27;,&#x27;123456&#x27;),(2,&#x27;李四&#x27;,&#x27;123456&#x27;),(3,&#x27;王五&#x27;,&#x27;123456&#x27;);SELECT * FROM `testmd5`;-- 加密UPDATE testmd5 SET pwd=MD5(pwd) WHERE id=2;-- 插入的时候加密INSERT INTO `testmd5`(`id`,`name`,`pwd`)VALUES(4,&#x27;小明&#x27;,MD5(&#x27;123456&#x27;));-- 如何校验，将用户传递进来的密码，进行MD5加密，然后比对加密后的值SELECT * FROM `testmd5` WHERE `name`=&#x27;小明&#x27; AND pwd = MD5(&#x27;123456&#x27;); 27、select小结28、事务ACID原则、脏读、不可重复读、幻读1.什么是事务==要么都成功，要么都失败== 将一组sql放到一个批次中取执行 事务原则：ACID原则 原子性 、一致性、隔离性、持久性 （脏读，幻读。。。） 参考博客链接：事务ACID理解 原子性（Atomicity） 要么都成功，要么都失败 一致性（Consistency） 事务前后的数据完整性要保持一致 下图操作前和操作后的总和都是1000 隔离性（Isolation） 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability） 事务一旦移交不可逆，被持久化到数据库中 隔离所导致的一些问题 脏读：1、在事务A执行过程中，事务A对数据资源进行了修改，事务B读取了事务A修改后的数据。 2、由于某些原因，事务A并没有完成提交，发生了RollBack操作，则事务B读取的数据就是脏数据。 这种读取到另一个事务未提交的数据的现象就是脏读(Dirty Read)。 不可重复读：事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的数据不一致。 这种**==在同一个事务中==，前后两次读取的数据不一致的现象就是不可重复读(Nonrepeatable Read)。** 虚读(幻读)事务B前后两次读取同一个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后一次读取到前一次查询没有看到的行。 幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。 第一类更新丢失事务A和事务B都对数据进行更新，但是事务A由于某种原因事务回滚了，把已经提交的事务B的更新数据给覆盖了。这种现象就是第一类更新丢失。 第二类更新丢失其实跟第一类更新丢失有点类似，也是两个事务同时对数据进行更新，但是事务A的更新把已提交的事务B的更新数据给覆盖了。这种现象就是第二类更新丢失。 事务隔离级别为了解决以上的问题，主流的关系型数据库都会提供四种事务的隔离级别。事务隔离级别从低到高分别是：读未提交，读已提交，可重复读，串行化。事务隔离级别越高，越能保证数据的一致性和完整性，但是执行效率也越低，所以在设置数据库的事务隔离级别时需要做一下权衡，mysql默认是可重复读 读未提交读未提交(Read Uncommitted)，是最低的隔离级别，所有的事务都可以看到其他未提交的事务的执行结果。只能防止第一类更新丢失，不能解决脏读，可重复读，幻读，所以很少应用于实际项目。 读已提交读已提交(Read Committed)，在该隔离级别下，一个事务的更新操作只有在该事务提交之后，另外一个事务才可能读取到同一笔数据更新后的结果。可以防止脏读和第一类更新丢失，但是不能解决可重复和幻读的问题。 可重复读（重要）可重复读(Repeatable Read)，mysql默认的隔离级别。在该隔离级别下，一个事务多次读同一个数据，在这个事务还没有结束时，其他事务不能访问该数据（包括了读写），这样就可以在同一个事务内两次读到的数据是一样的。可以防止脏读、不可重复读、第一类更新丢失，第二类更新丢失的问题，不过还是会出现幻读。 串行化串行化(Serializable)，这是最高的隔离级别。它要求事务序列化执行，事务只能一个接着一个的执行，不能并发执行。在这个级别，可以解决上面提到的所有并发问题，但是可能导致大量的超时现象和锁竞争，通常不会用这个隔离级别。 总结 扩展：回滚机制在mysql中，恢复机制是通过回滚日志（undo log）实现的，所有的事务进行的修改都会先记录到这个回滚日志中，然后在堆数据库中的对应进行写入。 mysql的事务是由redo和undo的，redo操作的所有信息都是记录到重做日志（redo_log）中，也就是说当一个事务做commit操作时，需要先把这个事务的操作写到redo_log中，然后在把这些操作flush到磁盘上，当出现故障时，只需要读取redo_log，然后在重新flush到磁盘就行了。 而对于undo就比较麻烦，mysql在处理事务时，会在数据共享表空间里申请一个段就做segment段，用保存undo信息，当在处理rollback，不是完完全全的物理undo，而是逻辑undo，也就是说会之前的操作进行反操作（对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。），但是这些共享表空间是不进行回收的。这些表空间的回收需要由mysql的master thread进程进行回收。 29、测试事务实现转账 执行事务 123456789101112131415161718192021222324252627282930-- 事务-- mysql 是默认开启事务自动提交-- 关闭SET autocommit = 0; -- 开启（默认的）SET autocommit = 1;-- 手动处理事务SET autocommit = 0; -- 关闭自动提交-- 事务开启START TRANSACTION; -- 标记一个事务的开始，从这个之后的sql都在同一个事务内INSERT XXINSERT XX-- 提交 ： 持久化COMMIT;-- 回滚 ： 回到的原来的样子（失败）ROLLBACK;-- 事务结束SET autocommit = 1; -- 开启自动提交-- 了解SAVEPOINT 保存点名 -- 设置一个事务的保存点ROLLBACK TO SAVEPOINT 保存点名 -- 回滚到保存点RELEASE SAVEPOINT 保存点名 -- 撤销保存点 模拟场景 1234567891011121314151617181920212223242526272829303132333435-- 转账-- 创建数据库CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci;-- 使用shop数据库USER `shop`;-- 建表CREATE TABLE `account`( `id` INT(3) NOT NULL AUTO_INCREMENT, `name` VARCHAR(100) NOT NULL, `money` DECIMAL(9,2) NOT NULL, PRIMARY KEY (`id`))ENGINE=INNODB DEFAULT CHARSET=utf8;-- 初始化数据INSERT INTO account(`name`,`money`)VALUES(&#x27;A&#x27;,2000.00),(&#x27;B&#x27;,10000.00);-- 模拟转账SET autocommit = 0; -- 关闭自动提交START TRANSACTION; -- 开启事务 （一组事务）UPDATE account SET `money`=`money`-500 WHERE `name`=&#x27;A&#x27;; -- A减500UPDATE account SET `money`=`money`+500 WHERE `name`=&#x27;B&#x27;; -- B加500COMMIT; -- 提交事务，就会被持久化了ROLLBACK; -- 回滚SET autocommit = 1; -- 恢复自动提交 30、索引介绍及索引的分类 Msql官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构。 提取句子主干，就可以得到索引的本质：索引是数据结构。 1.索引的分类 在一个表中，主键索引只能有一个，唯一索引可以有多个 主键索引（primary key） 唯一的标识，主键不可重复，只能有一个列作为主键 唯一索引 （unique key） 避免重复的列出现，可以重复，多个列都可以标示为唯一索引 常规索引（key/index） 默认的 index 或者key关键字来设置 全文索引（FullText） 在特定的数据库引擎下才有，myisam 快速定位数据 基础语法 1234567891011121314151617181920-- 索引的使用-- 1.在创建表的时候给字段增加索引-- 2.创建完毕后，增加索引-- 显示所有的索引信息SHOW INDEX FROM student;-- 新增一个索引 (索引名) 列名ALTER TABLE `student` ADD UNIQUE KEY `UK_IDENTITY_CARD` (`identity_card`);ALTER TABLE `student` ADD KEY `K_STUDENT_NAME`(`student_name`);ALTER TABLE `student` ADD FULLTEXT INDEX `FI_PHONE` (`phone`);-- explain 分析sql执行的状况EXPLAIN SELECT * FROM student; -- 非全文索引EXPLAIN SELECT * FROM student WHERE MATCH(`phone`) AGAINST(&#x27;138&#x27;); -- 全文索引 【MySQL优化】——看懂explain_漫漫长途，终有回转；余味苦涩，终有回甘-CSDN博客_explain 31、SQL编程创建100万条数据测试索引123456789101112131415161718192021222324252627282930313233343536373839404142434445464748CREATE TABLE app_user ( `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#x27;ID&#x27;, `name` VARCHAR(50) DEFAULT &#x27;&#x27; COMMENT &#x27;用户昵称&#x27;, `email` VARCHAR(50) NOT NULL COMMENT &#x27;用户邮箱&#x27;, `phone` VARCHAR(20) DEFAULT &#x27;&#x27; COMMENT &#x27;手机号&#x27;, `gender` TINYINT(4) UNSIGNED DEFAULT &#x27;0&#x27; COMMENT &#x27;性别（0：男 1：女）&#x27;, `password` VARCHAR(100) NOT NULL COMMENT &#x27;密码&#x27;, `age` TINYINT(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;, `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;, `update_time` TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;app用户表&#x27;-- 插入100万数据b (函数)DELIMITER $$ -- 写函数之前必须要写，标志CREATE FUNCTION mock_data()RETURNS INTBEGIN DECLARE num INT DEFAULT 1000000; DECLARE i INT DEFAULT 0; WHILE i&lt;num DO INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`) VALUES(CONCAT(&#x27;用户&#x27;,i),&#x27;123345@qq.com&#x27;,CONCAT(&#x27;18&#x27;,FLOOR(RAND()*((999999999-100000000)+100000000))),FLOOR(RAND()*2),UUID(),FLOOR(RAND()*100)); SET i = i+1; END WHILE; RETURN i;END;-- 执行函数SELECT mock_data();SELECT * FROM app_user;-- 函数中间的插入脚本INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`)VALUES(CONCAT(&#x27;用户X&#x27;),&#x27;123345@qq.com&#x27;,CONCAT(&#x27;18&#x27;,FLOOR(RAND()*((999999999-100000000)+100000000))),FLOOR(RAND()*2),UUID(),FLOOR(RAND()*100)); 测试 1234567891011-- 加索引前SELECT * FROM app_user WHERE `name` = &#x27;用户9999&#x27;; -- 0.440 secEXPLAIN SELECT * FROM app_user WHERE `name` = &#x27;用户9999&#x27;;-- 创建索引-- id_表名_字段名 索引名-- CREATE INDEX 索引名 ON 表名(`字段名`);CREATE INDEX id_app_user_name ON app_user(`name`); -- 加索引后SELECT * FROM app_user WHERE `name` = &#x27;用户9999&#x27;; -- 0.002 secEXPLAIN SELECT * FROM app_user WHERE `name` = &#x27;用户9999&#x27;; 加索引前 加索引后 索引在小数据量的时候，用处不大，但是再大数据的时候，区分十分明显 32、索引原则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表不需要加索引 索引一般加载常用来查询的字段上 索引的数据结构 Hash类型的索引 bree ：innodb的默认数据结构 CodingLabs - MySQL索引背后的数据结构及算法原理 33、数据库用户管理 sql yog 可视化管理 sql 命令操作 用户表：mysql.user 本质:读这张表进行增删改查 12345678910111213141516171819202122232425262728293031-- 创建用户CREATE USER zyy IDENTIFIED BY &#x27;123456&#x27;;-- 修改密码(修改当前用户密码)SET PASSWORD = PASSWORD(&#x27;123456&#x27;);-- 修改密码(修改指定用户密码)SET PASSWORD FOR zyy = PASSWORD(&#x27;123456&#x27;);-- 重命名 RENAME 原名子 zyy TO 新名字;RENAME USER zyy TO newzyy;-- 用户授权 ALL PRIVILEGES 全部的权限，库，表-- ALL PRIVILEGES 除了给别人授权不行，其他都能干GRANT ALL PRIVILEGES ON *.* TO newzyy;-- 查询权限SHOW GRANTS FOR newzyy; -- 查看指定用户的权限SHOW GRANTS FOR root@localhost; -- 查看root用户的权限-- 撤销权限 REVOKE哪些权限，在哪个库，给谁撤销REVOKE ALL PRIVILEGES ON *.* FROM newzyy;-- 删除用户DROP USER newzyy; 34、MySQL备份为什么要备份？ 保证重要的数据不丢失 数据转移 mysql数据库备份的方式 直接拷贝物理文件 在sqlyog这种可视化工具中手动导出 在想要导出的表或者库中，右键， 使用命令行导出 mysqldump 命令行使用 1234567891011121314# 一张表 mysqldump -h主机 -u用户名 -p密码 数据库 表名 &gt;物理磁盘位置/文件名mysqldump -hlocalhost -uroot -p123456 school student &gt;D:/a.sql# 多张表 mysqldump -h主机 -u用户名 -p密码 数据库 表名1 表名2 &gt;物理磁盘位置/文件名mysqldump -hlocalhost -uroot -p123456 school student result &gt;D:/a.sql# 数据库 mysqldump -h主机 -u用户名 -p密码 数据库 &gt;物理磁盘位置/文件名mysqldump -hlocalhost -uroot -p123456 school &gt;D:/a.sql# 导入# 登录的情况下，切换到指定的数据库# source 备份文件# 也可以这样mysql -u用户名 -p密码 库名&lt;备份文件 假设你要备份数据库，防止数据丢失。 把数据库给别人，直接给sql即可。 35、如何设计一个项目的数据库1.为什么需要设计==当数据库比较复杂的时候，我们就需要设计了== 糟糕的数据库设计 数据冗余，浪费空间 数据库插入和删除都会麻烦、异常（屏蔽使用物理外键） 程序的性能差 良好的数据库设计 节省内存空间 保证数据库的完整性 方便我们开发系统 软件开发中，关于数据库的设计 分析需求，分析业务和需要处理的数据库的需求 概要设计：设计关系图E-R图 设计数据库的步骤（个人博客） 收集信息，分析需求 用户表（用户登录注销，用户的个人信息，写博客，创建分类） 分类表（文章分类，谁创建的） 文章表（文章信息） 评论表 友链表（友情链接信息） 自定义表（系统信息，某个关键的字，或者一些主字段） key:value 关注表(粉丝数) 说说表（发表心情， id…content…create_time） 标识实体（把需求落到每个字段） 标识实体之间的关系 写博客：user –&gt; blog 创建分类：user –&gt; category 关注：user –&gt; user 友链：links 评论：user –&gt; user –&gt; blog (bbs / crm) 36、数据库三大范式（了解）为什么需要数据规范化？ 信息重复 更新异常 插入异常 无法正常显示信息 删除异常 丢失有效的信息 三大范式 第一范式（1NF） 原子性：保证每一列不可再分 第二范式（2NF） 前提：满足第一范式 第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。 每张表只描述一件事情 第三范式（3NF） 前提：满足第一范式和第二范式 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 规范数据库的设计 规范性和性能的问题 关联查询的表不得超过三张表 考虑商业化的需求和目标（成本，用户体验）数据库的性能更加重要 在规范性能的问题的时候，需要适当的考虑一下规范性 故意给某些表增加一些冗余的字段。（从多表查询中变为单表查询） 故意增加一些计算列（从大数据库降低为小数据量的查询：索引） 37、数据库驱动和JDBC1.数据库驱动驱动：声卡，显卡，数据库 我们的程序会通过数据库驱动，和数据库打交道！ 2.JDBCSUN公司为了简化开发人员的（对数据库的统一）操作，提供了一个（java操作数据库的）规范，俗称JDBC 这些规范的实现由具体的厂商去做~ 对于开发人员来说，我们只需要掌握JDBC接口的操作即可！ java.sql javax.sql 还需要导入一个数据库驱动包 mysql-connector-java-5.1.47.jar 38、第一个JDBC程序 创建测试数据库 12345678910111213141516CREATE DATABASE jdbcstudy CHARACTER SET utf8 COLLATE utf8_general_ci;USER jdbcstudy;CREATE TABLE users( `id` INT PRIMARY KEY, `name` VARCHAR(40), `password` VARCHAR(40), `email` VARCHAR(60), `birthday` DATE);INSERT INTO users(`id`,`name`,`password`,`email`,`birthday`)VALUES(1,&#x27;张三&#x27;,&#x27;123456&#x27;,&#x27;zs@sina.com&#x27;,&#x27;1980-12-04&#x27;),(2,&#x27;李四&#x27;,&#x27;123456&#x27;,&#x27;lisi@sina.com&#x27;,&#x27;1981-12-04&#x27;),(3,&#x27;王五&#x27;,&#x27;123456&#x27;,&#x27;wangwu@sina.com&#x27;,&#x27;1982-12-04&#x27;); 创建一个普通项目 导入数据库驱动（jar包） 编写测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * @ClassName: JDBCDemo01 * @Description: 我的第一个JDBC程序 * @Author: zyy * @Date: 2021/07/13 21:59 * @Version: 1.0 */public class JDBCDemo01 &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //1.加载驱动// DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //推荐这种写法加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.用户信息和URL // useSSL=true可能会报错 String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&quot;; String userName = &quot;root&quot;; String passWord = &quot;123456&quot;; //3.连接成功，数据库对象 Connection代表数据库 Connection connection = DriverManager.getConnection(url, userName, passWord); //4.执行SQl的对象 Statement 执行的sql对象 Statement statement = connection.createStatement(); //5.执行SQL的对象 去 执行SQL ，可能存在结果，查看返回的结果 String sql = &quot;SELECT * FROM users&quot;; //返回的结果集 结果集中封装了我们全部的查询的结果 ResultSet resultSet = statement.executeQuery(sql); while (resultSet.next()) &#123; System.out.println(&quot;id=&quot;+resultSet.getObject(&quot;id&quot;)); System.out.println(&quot;name=&quot;+resultSet.getObject(&quot;name&quot;)); System.out.println(&quot;password=&quot;+resultSet.getObject(&quot;password&quot;)); System.out.println(&quot;email=&quot;+resultSet.getObject(&quot;email&quot;)); System.out.println(&quot;birthday=&quot;+resultSet.getObject(&quot;birthday&quot;)); System.out.println(&quot;===============================&quot;); &#125; //6.释放连接 resultSet.close(); statement.close(); connection.close(); &#125;&#125; 步骤总结： 加载驱动 连接数据库DriverManager 获取执行SQL的对象 Statement 获得返回的结果集 释放连接 39、JDBC中对象1解释 DriverManager 12345678910111213//1.加载驱动//DriverManager.registerDriver(new com.mysql.jdbc.Driver());//推荐这种写法加载驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);Connection connection = DriverManager.getConnection(url, userName, passWord);// connection代表数据库// 数据库设置自动提交// 事务提交// 事务回滚connection.setAutoCommit(true);connection.commit();connection.rollback(); URL 123456String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&quot;;// mysql默认端口3306// 协议://主机地址:端口号/数据库名?参数1&amp;参数2&amp;参数3// oracle默认端口1521// jdbc:oracle:thin:@localhost:1521:sid Statement 执行sql对象 、 PreparedStatement 执行sql对象 12345String sql = &quot;SELECT * FROM users&quot;;//编写SQLstatement.executeQuery();//执行查询 返回ResultSetstatement.executeUpdate();//新增，删除，修改，都用这个，返回受影响的行数statement.execute();//执行任何SQL ResultSet 查询的结果集，封装了所有的查询结果 获得指定的数据类型 12345678910//在不知道列类型的情况下使用resultSet.getObject();//如果知道列类型，就使用指定的类型resultSet.getString();resultSet.getInt();resultSet.getDouble();resultSet.getBigDecimal();resultSet.getFloat();resultSet.getDate();//... 遍历，指针 12345resultSet.beforeFirst();//移动到最前面resultSet.afterLast();//移动到最后面resultSet.next();//移动到下一个数据resultSet.previous();//移动到前一行resultSet.absolute(row);//移动到指定行 释放资源 123resultSet.close();statement.close();connection.close();//消耗资源 40、statement对象详解==jdbc中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可。== Statement对象的executeUpdate方法，用于向数据库发送增、删、改的SQL语句，executeUpdate执行完后，将会返回一个整数（即增删改语句导致了数据库几行数据发送了变化）。 Statement.executeQuery方法用于向数据库发送查询语句，executeQuery方法返回代表查询结果的ResultSet对象。 CRUD操作-create 使用executeUpdate(String sql)方法完成数据添加操作，示例操作： 123456Statement statement = connection.createStatement();String sql = &quot;insert into user(...) values(...)&quot;;int num = statement.executeUpdate(sql);if (num &gt; 0) &#123; System.out.println(&quot;插入成功~&quot;);&#125; CRUD操作-delete 123456Statement statement = connection.createStatement();String sql = &quot;delete from user where id=1&quot;;int num = statement.executeUpdate(sql);if (num &gt; 0) &#123; System.out.println(&quot;删除成功~&quot;);&#125; CRUD操作-update 123456Statement statement = connection.createStatement();String sql = &quot;update user set name=&#x27;&#x27; where name =&#x27;&#x27;&quot;;int num = statement.executeUpdate(sql);if (num &gt; 0) &#123; System.out.println(&quot;修改成功~&quot;);&#125; CRUD操作-read 123456Statement statement = connection.createStatement();String sql = &quot;SELECT * FROM users&quot;;ResultSet resultSet = statement.executeQuery(sql);while (resultSet.next()) &#123; //根据获取列的数据类型，分别调用resultSet的相应方法映射到java对象中&#125; 代码实现 提取工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/** * @ClassName: JDBCUtils * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 17:48 * @Version: 1.0 */public class JDBCUtils &#123; private static String driver = null; private static String url = null; private static String username = null; private static String password = null; static &#123; try &#123; InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); Properties properties = new Properties(); properties.load(in); driver = properties.getProperty(&quot;driver&quot;); url = properties.getProperty(&quot;url&quot;); username = properties.getProperty(&quot;username&quot;); password = properties.getProperty(&quot;password&quot;); //驱动只用加载一次 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, username, password); &#125; /** * 释放资源 */ public static void release(Connection con, Statement st, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st != null) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (con != null) &#123; try &#123; con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 配置文件db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falseusername=rootpassword=123456 编写增删改的方法，executeUpdate 12345678910111213141516171819202122232425262728293031323334353637import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * @ClassName: TestInsert * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 18:19 * @Version: 1.0 */public class TestInsert &#123; public static void main(String[] args) &#123; Connection con = null; Statement st = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); st = con.createStatement(); String sql = &quot;INSERT INTO users(`id`,`name`,`password`,`email`,`birthday`)\\n&quot; + &quot;VALUES (5,&#x27;钱七&#x27;,&#x27;123456&#x27;,&#x27;qianqi@sina.com&#x27;,&#x27;1988-12-04&#x27;)&quot;; int num = st.executeUpdate(sql); if (num &gt; 0) &#123; System.out.println(&quot;插入成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(con, st, rs); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * @ClassName: TestDelete * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 22:11 * @Version: 1.0 */public class TestDelete &#123; public static void main(String[] args) &#123; Connection con = null; Statement st = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); st = con.createStatement(); String sql = &quot;DELETE FROM users WHERE `id`=5&quot;; int num = st.executeUpdate(sql); if (num &gt; 0) &#123; System.out.println(&quot;删除成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(con, st, rs); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * @ClassName: TestUpdate * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 22:11 * @Version: 1.0 */public class TestUpdate &#123; public static void main(String[] args) &#123; Connection con = null; Statement st = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); st = con.createStatement(); String sql = &quot;UPDATE users SET birthday=&#x27;1990-12-01&#x27; WHERE id=1&quot;; int num = st.executeUpdate(sql); if (num &gt; 0) &#123; System.out.println(&quot;更新成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(con, st, rs); &#125; &#125;&#125; 查询 12345678910111213141516171819202122232425262728293031323334353637import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * @ClassName: TestSelect * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 22:11 * @Version: 1.0 */public class TestSelect &#123; public static void main(String[] args) &#123; Connection con = null; Statement st = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); st = con.createStatement(); String sql = &quot;SELECT * FROM users WHERE id=1&quot;; rs = st.executeQuery(sql); while (rs.next()) &#123; System.out.println(&quot;id=&quot;+rs.getInt(&quot;id&quot;)); System.out.println(&quot;name=&quot;+rs.getString(&quot;name&quot;)); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(con, st, rs); &#125; &#125;&#125; 41、sql注入问题sql存在漏洞，会被攻击导致数据泄露 ==SQL会被拼接== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * @ClassName: SQLQuestion * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 22:23 * @Version: 1.0 */public class SQLQuestion &#123; public static void main(String[] args) &#123; //正常登录// login(&quot;张三&quot;,&quot;1234567&quot;); //sql注入 login(&quot;&#x27; or &#x27;1=1&quot;,&quot;123456&quot;); &#125; /** * 登录业务 */ public static void login(String userName, String password) &#123; Connection con = null; Statement st = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); st = con.createStatement(); String sql = &quot;SELECT * FROM users WHERE `name`=&#x27;&quot;+userName+&quot;&#x27; AND `password`=&#x27;&quot;+password+&quot;&#x27;&quot;; // SELECT * FROM users WHERE `name`=&#x27;&#x27; or &#x27;1=1&#x27; AND `password`=&#x27;123456&#x27; System.out.println(sql); rs = st.executeQuery(sql); while (rs.next()) &#123; System.out.println(&quot;id=&quot;+rs.getInt(&quot;id&quot;)); System.out.println(&quot;name=&quot;+rs.getString(&quot;name&quot;)); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(con, st, rs); &#125; &#125;&#125; 导致结果：错误的用户名或者密码可以获取到全部的用户信息 42、PreparedStatement对象PreparedStatement可以防止SQL注入，效率更好 新增 1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: TestInsert * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 18:19 * @Version: 1.0 */public class TestInsert &#123; public static void main(String[] args) &#123; Connection con = null; PreparedStatement st = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); //使用?占位符代替参数 String sql = &quot;INSERT INTO users(`id`,`name`,`password`,`email`,`birthday`) VALUES (?,?,?,?,?)&quot;; //预编译SQL，先写SQL，然后不执行 st = con.prepareStatement(sql); //手动给参数赋值 st.setInt(1, 5); st.setString(2, &quot;钱七&quot;); st.setString(3, &quot;123456&quot;); st.setString(4, &quot;qianqi@sina.com&quot;); st.setDate(5, new java.sql.Date(new java.util.Date().getTime())); int num = st.executeUpdate(); if (num &gt; 0) &#123; System.out.println(&quot;插入成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(con, st, rs); &#125; &#125;&#125; 删除 12345678910111213141516171819202122232425262728293031323334353637383940import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: TestDelete * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 18:19 * @Version: 1.0 */public class TestDelete &#123; public static void main(String[] args) &#123; Connection con = null; PreparedStatement st = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); //使用?占位符代替参数 String sql = &quot;DELETE FROM users WHERE `id`=?&quot;; //预编译SQL，先写SQL，然后不执行 st = con.prepareStatement(sql); //手动给参数赋值 st.setInt(1, 5); int num = st.executeUpdate(); if (num &gt; 0) &#123; System.out.println(&quot;删除成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(con, st, rs); &#125; &#125;&#125; 更新 1234567891011121314151617181920212223242526272829303132333435363738394041import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: TestUpdate * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 18:19 * @Version: 1.0 */public class TestUpdate &#123; public static void main(String[] args) &#123; Connection con = null; PreparedStatement st = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); //使用?占位符代替参数 String sql = &quot;UPDATE users SET birthday=? WHERE id=?&quot;; //预编译SQL，先写SQL，然后不执行 st = con.prepareStatement(sql); //手动给参数赋值 st.setDate(1, new java.sql.Date(new java.util.Date().getTime())); st.setInt(2, 1); int num = st.executeUpdate(); if (num &gt; 0) &#123; System.out.println(&quot;修改成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(con, st, rs); &#125; &#125;&#125; 查询 12345678910111213141516171819202122232425262728293031323334353637383940import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: TestSelect * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 18:19 * @Version: 1.0 */public class TestSelect &#123; public static void main(String[] args) &#123; Connection con = null; PreparedStatement st = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); //使用?占位符代替参数 String sql = &quot;SELECT * FROM users WHERE id=?&quot;; //预编译SQL，先写SQL，然后不执行 st = con.prepareStatement(sql); //手动给参数赋值 st.setInt(1, 1); rs = st.executeQuery(); while (rs.next()) &#123; System.out.println(&quot;id=&quot;+rs.getInt(&quot;id&quot;)); System.out.println(&quot;name=&quot;+rs.getString(&quot;name&quot;)); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(con, st, rs); &#125; &#125;&#125; 防止sql注入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: SQLQuestion * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 18:19 * @Version: 1.0 */public class SQLQuestion &#123; public static void main(String[] args) &#123; //正常登录// login(&quot;张三&quot;,&quot;123456&quot;); //sql注入 login(&quot;&#x27; or &#x27;1=1&quot;, &quot;123456&quot;); &#125; /** * 登录业务 */ public static void login(String userName, String password) &#123; Connection con = null; PreparedStatement st = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); // PreparedStatement 防止SQL注入的本质，把传递进来的参数当做字符 // 假设其中存在转义字符，比如说&#x27;会被直接转义 String sql = &quot;SELECT * FROM users WHERE `name`=? AND `password`=?&quot;; st = con.prepareStatement(sql); st.setString(1, userName); st.setString(2, password); rs = st.executeQuery(); while (rs.next()) &#123; System.out.println(&quot;id=&quot; + rs.getInt(&quot;id&quot;)); System.out.println(&quot;name=&quot; + rs.getString(&quot;name&quot;)); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.release(con, st, rs); &#125; &#125;&#125; 执行结果：查不到任何结果 43、使用idea连接数据库 连接成功后，就可以选择数据库 连接不上的话，可以看一下下面这里，配置对应的mysql版本 双击数据库 更新数据（提交） idea编写sql 1234567891011create table account( id int primary key auto_increment, name varchar(40), money float);insert into account(name, money)values (&#x27;A&#x27;, 1000), (&#x27;B&#x27;, 1000), (&#x27;C&#x27;, 1000); 44、JDBC操作事务==要么都成功，要么都失败== ACID原则 原子性：要么全部成功，要么全部失败 一致性：总数不变 隔离性：多个进程互不干扰 持久性：一旦提交不可逆，持久化到数据库了 隔离性的问题： 脏读：一个事务读取了另外一个没有提交的事务 不可重复读：在同一个事务内，重复读取表中数据，表数据发生了改变 幻读：在一个事务内，读取到了别人插入的数据，导致前后读出来的结果不一致 代码实现 开启事务con.setAutoCommit(false); 一组业务执行完毕，提交事务 可以在catch语句中显示的定义回滚语句，但是默认失败就会回滚 正常情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: TestTransaction1 * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/15 21:59 * @Version: 1.0 */public class TestTransaction1 &#123; public static void main(String[] args) &#123; Connection con = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); //关闭自动提交 自动会开启事务 con.setAutoCommit(false);//开启事务 // A 转 B 100元 String sql1 = &quot;update account set money=money-100 where name=&#x27;A&#x27;&quot;; ps = con.prepareStatement(sql1); ps.executeUpdate(); String sql2 = &quot;update account set money=money+100 where name=&#x27;B&#x27;&quot;; ps = con.prepareStatement(sql2); ps.executeUpdate(); //业务完毕，提交事务 con.commit(); System.out.println(&quot;A 转 B 100元 成功！&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; con.rollback(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125; finally &#123; JDBCUtils.release(con, ps, rs); &#125; &#125;&#125; 异常情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import com.zyy.lesson02.utils.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: TestTransaction1 * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/15 21:59 * @Version: 1.0 */public class TestTransaction2 &#123; public static void main(String[] args) &#123; Connection con = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; con = JDBCUtils.getConnection(); //关闭自动提交 自动会开启事务 con.setAutoCommit(false);//开启事务 // A 转 B 100元 String sql1 = &quot;update account set money=money-100 where name=&#x27;A&#x27;&quot;; ps = con.prepareStatement(sql1); ps.executeUpdate(); //默认失败 int x = 1/0; //一定会异常 String sql2 = &quot;update account set money=money+100 where name=&#x27;B&#x27;&quot;; ps = con.prepareStatement(sql2); ps.executeUpdate(); //业务完毕，提交事务 con.commit(); System.out.println(&quot;A 转 B 100元 成功！&quot;); &#125; catch (SQLException e) &#123; e.printStackTrace(); //如果异常，默认也会回滚，下面不写也可以// try &#123;// con.rollback();// &#125; catch (SQLException ex) &#123;// ex.printStackTrace();// &#125; &#125; finally &#123; JDBCUtils.release(con, ps, rs); &#125; &#125;&#125; 45、DBCP-C3P0连接池数据库连接 – 执行完毕 – 释放 连接– 释放 是十分浪费系统资源的 池化技术：准备一些预先的资源，过来就连接预先准备好的 最小连接数：10(常用连接) 最大连接数：100 （业务最高承载上线） 等待超时：100ms 编写连接池，实现一个接口DataSource 开源数据源实现 DBCP C3p0 Druid:阿里巴巴 使用了这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码了 DBCP 需要用到的jar包 commons-dbcp-1.4 commons-pool-1.6 配置文件dbcp.properties 12345678910111213141516171819202122232425262728293031323334#连接设置driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falseusername=rootpassword=123456#初始化连接initialSize=10#最大连接数量maxActive=50#最大空闲连接maxIdle=20#最小空闲连接minIdle=5#超时等待时间以毫秒为单位 6000毫秒/1000等于60秒maxWait=60000#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：【属性名=property;】#注意：user 与 password 两个属性会被明确地传递，因此这里不需要包含他们。connectionProperties=useUnicode=true;characterEncoding=UTF8#指定由连接池所创建的连接的自动提交（auto-commit）状态。defaultAutoCommit=true#driver default 指定由连接池所创建的连接的只读（read-only）状态。#如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：Informix）defaultReadOnly=#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLEdefaultTransactionIsolation=READ_COMMITTED 工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import org.apache.commons.dbcp.BasicDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;/** * @ClassName: JDBCDBCPUtils * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 17:48 * @Version: 1.0 */public class JDBCDBCPUtils &#123; private static DataSource dataSource = null; static &#123; try &#123; InputStream in = JDBCDBCPUtils.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); Properties properties = new Properties(); properties.load(in); //创建数据源 工厂模式 dataSource = BasicDataSourceFactory.createDataSource(properties); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; //从数据源中获取连接 return dataSource.getConnection(); &#125; /** * 释放资源 */ public static void release(Connection con, Statement st, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st != null) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (con != null) &#123; try &#123; con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445import com.zyy.lesson02.utils.JDBCUtils;import com.zyy.lesson05.utils.JDBCDBCPUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: TestDBCP * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/15 22:41 * @Version: 1.0 */public class TestDBCP &#123; public static void main(String[] args) &#123; Connection con = null; PreparedStatement st = null; ResultSet rs = null; try &#123; con = JDBCDBCPUtils.getConnection(); //使用?占位符代替参数 String sql = &quot;INSERT INTO users(`id`,`name`,`password`,`email`,`birthday`) VALUES (?,?,?,?,?)&quot;; //预编译SQL，先写SQL，然后不执行 st = con.prepareStatement(sql); //手动给参数赋值 st.setInt(1, 5); st.setString(2, &quot;钱七&quot;); st.setString(3, &quot;123456&quot;); st.setString(4, &quot;qianqi@sina.com&quot;); st.setDate(5, new java.sql.Date(new java.util.Date().getTime())); int num = st.executeUpdate(); if (num &gt; 0) &#123; System.out.println(&quot;插入成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCDBCPUtils.release(con, st, rs); &#125; &#125;&#125; C3P0 需要用到的jar包 c3p0-0.9.5.5.jar mchange-commons-java-0.2.19.jar 配置文件c3p0-config.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;!-- c3p0的缺省（默认）配置 如果在代码中ComboPooledDataSource ds=new ComboPooledDataSource();这样写就表示使用的是c3p0的缺省（默认） --&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;acquiredIncrement&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt; &lt;/default-config&gt; &lt;!-- c3p0的命名配置 如果在代码中ComboPooledDataSource ds=new ComboPooledDataSource(&quot;MySQL&quot;);这样写就表示使用的是name是MySQL --&gt; &lt;name-config name=&quot;MySQL&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;acquiredIncrement&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;20&lt;/property&gt; &lt;/name-config&gt;&lt;/c3p0-config&gt; 工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import com.mchange.v2.c3p0.ComboPooledDataSource;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * @ClassName: JDBCC3P0Utils * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/14 17:48 * @Version: 1.0 */public class JDBCC3P0Utils &#123; private static DataSource dataSource = null; //private static ComboPooledDataSource dataSource = null; static &#123; try &#123; //代码的方式配置// dataSource = new ComboPooledDataSource();// dataSource.setDriverClass();// dataSource.setJdbcUrl();// dataSource.setUser();// dataSource.setPassword();// dataSource.setMaxPoolSize();// dataSource.setMinPoolSize(); //配置文件写法 dataSource = new ComboPooledDataSource(&quot;MySQL&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; //从数据源中获取连接 return dataSource.getConnection(); &#125; /** * 释放资源 */ public static void release(Connection con, Statement st, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st != null) &#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (con != null) &#123; try &#123; con.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142434445import com.zyy.lesson05.utils.JDBCC3P0Utils;import com.zyy.lesson05.utils.JDBCDBCPUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: TestC3P0 * @Description: TODO 类描述 * @Author: zyy * @Date: 2021/07/15 22:41 * @Version: 1.0 */public class TestC3P0 &#123; public static void main(String[] args) &#123; Connection con = null; PreparedStatement st = null; ResultSet rs = null; try &#123; con = JDBCC3P0Utils.getConnection(); //使用?占位符代替参数 String sql = &quot;INSERT INTO users(`id`,`name`,`password`,`email`,`birthday`) VALUES (?,?,?,?,?)&quot;; //预编译SQL，先写SQL，然后不执行 st = con.prepareStatement(sql); //手动给参数赋值 st.setInt(1, 6); st.setString(2, &quot;刘八&quot;); st.setString(3, &quot;123456&quot;); st.setString(4, &quot;liuba@sina.com&quot;); st.setDate(5, new java.sql.Date(new java.util.Date().getTime())); int num = st.executeUpdate(); if (num &gt; 0) &#123; System.out.println(&quot;插入成功！&quot;); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCC3P0Utils.release(con, st, rs); &#125; &#125;&#125; 总结 无论用什么数据源，本质还是一样的，DataSource接口不会变，方法就不会变 Welcome to The Apache Software Foundation!","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"玫瑰少年","slug":"玫瑰少年","date":"2022-03-18T16:00:00.000Z","updated":"2022-03-19T05:56:07.470Z","comments":true,"path":"2022/03/19/玫瑰少年/","link":"","permalink":"http://example.com/2022/03/19/%E7%8E%AB%E7%91%B0%E5%B0%91%E5%B9%B4/","excerpt":"","text":"玫瑰少年- 五月天谁把谁的灵魂 装进谁的身体谁把谁的身体 变成囹圄囚禁自己乱世总是最 不缺耳语哪种美丽会 换来妒忌你并没有罪 有罪是这世界生而为人无罪 你不需要抱歉ONE day I wIll be you baby boy and you Gon’be me喧哗如果不停 让我陪你安静I wIsh I could hug you tIll you’re really really being free哪朵玫瑰没有荆棘最好的 报复是 美丽最美的 盛开是 反击别让谁去 改变了你你是你 或是妳 都行会有人 全心的 爱你试着想像 you swItched to hIs bodySeXualIty 当心什么会伤你多少次的重伤 多少次的冷语Drowning 谁会拉你Dreaming 谁会陪你Same s**t happens every day你离开后 世界可改变多少无知罪愆 事过不境迁永志不忘纪念 往事不如烟生而为人无罪 你不需要抱歉ONE day I wIll be you baby boy and you Gon’be me喧哗如果不停 让我陪你安静I wIsh I could hug you tIll you’re really really being free哪朵玫瑰没有荆棘最好的 报复是 美丽最美的 盛开是 反击别让谁去 改变了你你是你 或是妳 都行会有人 全心的 爱你玫瑰少年 在我心里绽放着 鲜艳的 传奇我们都 从来没 忘记你的控诉 没有声音却倾诉 更多的 真理却唤醒 无数的 真心哪朵玫瑰没有荆棘最好的 报复是 美丽最美的 盛开是 反击别让谁去 改变了你你是你 或是妳 都行会有人 全心的 爱你玫瑰少年 在我心里玫瑰少年 在我心里","categories":[],"tags":[{"name":"五月天","slug":"五月天","permalink":"http://example.com/tags/%E4%BA%94%E6%9C%88%E5%A4%A9/"}]},{"title":"JavaSE知识体系","slug":"JavaSE知识体系","date":"2021-12-10T16:00:00.000Z","updated":"2022-04-04T15:10:50.694Z","comments":true,"path":"2021/12/11/JavaSE知识体系/","link":"","permalink":"http://example.com/2021/12/11/JavaSE%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","excerpt":"","text":"JavaSE知识梳理2. 数据类型2.1 基本类型 数据类型 包装类 所占字节 boolean Boolean 未定 byte Byte 1字节 char Character 2字节 short Short 2字节 int Integer 4字节 float Float 4字节 long Long 8字节 double Double 8字节 2.2 其它类型 2.3 类型转换 小类型自动转换为大类型 3. 运算符3.1 赋值运算符 3.2 算数运算符 3.3 关系运算符 3.4 位运算符 3.5 运算符优先级 运算符优先级常规掌握就好，在开发中通常使用括号明确运算的优先级关系 3.6 问题思考 4. 程序三大逻辑结构4.1 顺序从上到下 4.2 分支 4.3 循环 5. 数组5.1 知识点 5.2 技术问题 5.3 Arrays常用函数5.3.1 Arrays.sort(int[] a,int fromIndex,int toIndex) Arrays.sort()只能给int[] 形的数组排序，不能给动态数组ArrayList排序。 Arrays.sort()按升序排序，要按降序排序的话还挺麻烦的。 void Arrays.sort(int[] a) –&gt; 将数组a升序排序 void Arrays.sort(int[] a,int fromIndex,int toIndex) –&gt; 将fromIndex与toIndex之间的元素进行排序(备注：fromIndex（起始索引），toIndex（终点索引）) 12345int[] b=&#123;1,5,9,8,6,3,7,4,2,10&#125;;Arrays.sort(b,5,9);for(int i:b)&#123; System.out.print(i+&quot; &quot;);&#125; 1输出：1 5 9 8 6 2 3 4 7 10 1解释：从5号索引到9号索引，即3、7、4、2、10 --&gt; 2、3、4、7、10 5.3.2 Arrays.fill() 用于给数组填充数字 12int[] nums=new int[5];Arrays.fill(nums, 6); 5.3.3 Arrays.equals() 用于对比两数组中的元素是否一样 123int[] nums1=&#123;2,6,8,1&#125;;int[] nums2=&#123;2,6,8,1&#125;;Arrays.equals(nums1,nums2); // true 5.3.4 Arrays.toString() 将数组转为字符串表示出来 123Character[] chars= &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;System.out.print(Arrays.toString(chars));// [a, b, c] 5.3.5Arrays.binarySearch() 判断数组中是否有某个元素，有的话返回该元素的坐标，否则返回-1 123int[] nums= &#123;3,6,8,5,1&#125;;System.out.println(Arrays.binarySearch(nums, 3)); // 0System.out.println(Arrays.binarySearch(nums, 0)); // -1","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaWeb基础知识","slug":"JavaWeb基础知识","date":"2021-10-23T16:00:00.000Z","updated":"2021-10-24T13:36:04.195Z","comments":true,"path":"2021/10/24/JavaWeb基础知识/","link":"","permalink":"http://example.com/2021/10/24/JavaWeb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Junit12345678910111213141516171819202122232425262728293031* 测试分类： 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试 * 步骤： 1. 定义一个测试类(测试用例) * 建议： * 测试类名：被测试的类名Test CalculatorTest * 包名：xxx.xxx.xx.test cn.itcast.test 2. 定义测试方法：可以独立运行 * 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 3. 给方法加@Test 4. 导入junit依赖环境 * 判定结果： * 红色：失败 * 绿色：成功 * 一般我们会使用断言操作来处理结果 * Assert.assertEquals(期望的结果,运算的结果); * 补充： * @Before: * 修饰的方法会在测试方法之前被自动执行 * @After: * 修饰的方法会在测试方法执行之后自动被执行","categories":[{"name":"JavaWeb基础","slug":"JavaWeb基础","permalink":"http://example.com/categories/JavaWeb%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JavaWeb基础","slug":"JavaWeb基础","permalink":"http://example.com/tags/JavaWeb%E5%9F%BA%E7%A1%80/"}]},{"title":"知识辨析","slug":"知识辨析","date":"2021-10-21T16:00:00.000Z","updated":"2022-03-19T05:49:04.327Z","comments":true,"path":"2021/10/22/知识辨析/","link":"","permalink":"http://example.com/2021/10/22/%E7%9F%A5%E8%AF%86%E8%BE%A8%E6%9E%90/","excerpt":"","text":"== 与 equals(重要)== : 它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型==⽐较的是值，引⽤数据类型==⽐较的是内存地址)。 equals:它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：情况 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐᫾该类的两个对象时，等价于通过“==”⽐较这两个对象。 情况 2：类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐᫾两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 说明: String 中的 equals ⽅法是被重写过的，因为 object 的 equals ⽅法是⽐᫾的对象的内存地 址，⽽ String 的 equals ⽅法⽐᫾的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相 同的对象，如果有就把它赋给当前引⽤。如果没有就在常量池中重新创建⼀个 String 对象。","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java基础问题合集","slug":"Java基础问题合集","date":"2021-10-16T16:00:00.000Z","updated":"2021-10-17T15:17:56.163Z","comments":true,"path":"2021/10/17/Java基础问题合集/","link":"","permalink":"http://example.com/2021/10/17/Java%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/","excerpt":"","text":"问题合集：什么是泛型？ 答：泛型：即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。泛型的本质：是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 Collection(Set List)Set的接口继承Collection接口，而且不允许集合中存在重复项。 List接口继承了Collection接口以定义一个允许重复项的有序集合。 Set：搜索元素效率低下，删除和插入的效率高，插入和删除不会引起元素的位置变化。 List：和数组类似，List可以动态增长，查找元素的效率较高，插入元素和删除元素效率低，因为会引起其他元素位置发生变化。 Set 和 List的具体子类： Set ----HashSet：以哈希表的形式存放元素，插入删除速度很快 List： ----ArrayList :动态数组 ----LinkedList:链表，队列，堆栈","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java集合详解","slug":"Java集合详解","date":"2021-10-11T04:13:35.000Z","updated":"2021-10-11T04:53:00.279Z","comments":true,"path":"2021/10/11/Java集合详解/","link":"","permalink":"http://example.com/2021/10/11/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"表 1 Java集合接口的作用 接口名称 作 用 Iterator 接口 集合的输出接口，主要用于遍历输出（即迭代访问）Collection 集合中的元素，Iterator 对象被称之为迭代器。迭代器接口是集合接口的父接口，实现类实现 Collection 时就必须实现 Iterator 接口。 Collection 接口 是 List、Set 和 Queue 的父接口，是存放一组单值的最大接口。所谓的单值是指集合中的每个元素都是一个对象。一般很少直接使用此接口直接操作。 Queue 接口 Queue 是 Java 提供的队列实现，有点类似于 List。 Dueue 接口 是 Queue 的一个子接口，为双向队列。 List 接口 是最常用的接口。是有序集合，允许有相同的元素。使用 List 能够精确地控制每个元素插入的位置，用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，与数组类似。 Set 接口 不能包含重复的元素。 Map 接口 是存放一对值的最大接口，即接口中的每个元素都是一对，以 key➡value 的形式保存。 ​ 对于 Set、List、Queue 和 Map 这 4 种集合，Java 最常用的实现类分别是 HashSet、TreeSet、ArrayList、ArrayDueue、LinkedList 和 HashMap、TreeMap 等。表 2 介绍了集合中这些常用的实现类。 表 2 Java集合实现类的作用 类名称 作用 HashSet 为优化査询速度而设计的 Set。它是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，实现比较简单 TreeSet 实现了 Set 接口，是一个有序的 Set，这样就能从 Set 里面提取一个有序序列 ArrayList 一个用数组实现的 List，能进行快速的随机访问，效率高而且实现了可变大小的数组 ArrayDueue 是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素 LinkedList 对顺序访问进行了优化，但随机访问的速度相对较慢。此外它还有 addFirst()、addLast()、getFirst()、getLast()、removeFirst() 和 removeLast() 等方法，能把它当成栈（Stack）或队列（Queue）来用 HsahMap 按哈希算法来存取键对象 TreeMap 可以对键对象进行排序","categories":[{"name":"集合","slug":"集合","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"字节流和字符流的用法","slug":"字节流和字符流的用法","date":"2021-10-10T16:00:00.000Z","updated":"2021-10-11T10:36:04.895Z","comments":true,"path":"2021/10/11/字节流和字符流的用法/","link":"","permalink":"http://example.com/2021/10/11/%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"字节流作用:字节流可以将文字图片音频等等文件转成字节进行数据传输分为:OutputStream: 输出流,写文件InputStream: 输入流,读文件 输出流的使用实例:12345678910111213141516// 创建一个字节输出流,写文件,设置文件路径,如果没有,系统会自动创建FileOutputStream fos = new FileOutputStream(&quot;Desktop/d.txt&quot;);// 写入方法write// 该方法是按ASCII码写入的fos.write(65);// 利用字节数组写入,同样是按ASCII码写入[A(65),B,C,D,E(69)]byte[] b = &#123;66,67,68,69&#125;;fos.write(b);// 将&quot;hello&quot; 转成字节数组写fos.write(&quot;hello&quot;.getBytes());// 按偏移量写入数组的字符,b代表数组名,1代表数组角标(数组索引值),2代表长度fos.write(b, 1, 2);// 关闭资源 fos.close(); 注意:写完要关闭资源,一般会判断一下,创建流时有可能发生异常,利用finally特性补充一下判断123456789finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(&quot;关闭失败&quot;); &#125; &#125; &#125; 输入流用来读取文件,有三种方法 单个读取 1234567891011// 设置读取路径FileInputStream fis = new FileInputStream(&quot;Desktop/heihei.txt&quot;);// fis.read读取int by = fis.read();// 转为字符输出,不然输出的ASCII的对应值System.out.println((char)by);// 继续读取by = fis.read();System.out.println((char)by);// 关闭资源fis.close(); 注意:当文件读取完毕时,返回值为-1 循环读取 1234567FileInputStream fis = new FileInputStream(&quot;Desktop/heihei.txt&quot;);int by = 0;//fis.read()为-1时,文件读取完毕while ((by = fis.read()) != -1) &#123; System.out.println((char)by); &#125; fis.close(); 利用字节数组读取 12345678910111213 FileInputStream fis = new FileInputStream(&quot;Desktop/heihei.txt&quot;);// 创建数组,数组长度一般为1024的倍数byte[] b = new byte[1024];// 接收有效长度int len = 0;// fis.read(b)返回值是有效长度 while ((len = fis.read(b)) != -1) &#123;// 使用字符串的构造方法打印 System.out.println(new String(b, 0, len));&#125;fis.close(); 字符流分为:FileWriter: 写入文件FileReader: 读取文件 输出流使用方法​ 123456789101112131415161718// 创建字符输出流FileWriter fw = new FileWriter(&quot;Desktop/hh.txt&quot;);// 写入文件fw.write(65);// 刷新(会将内容写入到文件中,如果不刷新,将不会写入)fw.flush(); // 字符数组写入char[] c =&#123;&#x27;7&#x27;,&#x27;8&#x27;&#125;;fw.write(c);fw.flush();// 字符串直接写入// 换行 \\n (mac系统) \\r\\n(windows) \\n(Linux)fw.write(&quot;我的\\n&quot;);fw.write(&quot;世界\\n&quot;);fw.flush(); // 关闭资源// 关闭前,系统自动刷新fw.close(); 输入流读取文件使用,同样三种方法(与字节流基本相同) 单个读取 12345678910// 设置读取路径FileReader fr = new FileReader(&quot;Desktop/heihei.txt&quot;);int num = fr.read();System.out.println((char)num);// 继续读取num = fr.read();// 强转为字符输出System.out.println((char)num);// 关闭资源fr.close(); 循环读取 12345678// 设置读取路径FileReader fr = new FileReader(&quot;Desktop/heihei.txt&quot;);int num = 0;while ((num = fr.read()) != -1) &#123;// 强转为字符输出 System.out.print((char)num);&#125;fr.close(); 利用字符数组读取 1234567FileReader fr = new FileReader(&quot;Desktop/heihei.txt&quot;); char[] c = new char[1024]; int len = 0; while ((len = fr.read(c)) ! = -1) &#123; System.out.println(new String(c, 0, len)); &#125; fr.close();","categories":[{"name":"IO流","slug":"IO流","permalink":"http://example.com/categories/IO%E6%B5%81/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"List集合中方法总结","slug":"List集合中方法总结","date":"2021-10-10T14:53:42.000Z","updated":"2021-10-10T15:21:45.508Z","comments":true,"path":"2021/10/10/List集合中方法总结/","link":"","permalink":"http://example.com/2021/10/10/List%E9%9B%86%E5%90%88%E4%B8%AD%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"List集合常用方法由于List集合中的ArrayList与LinkedList都是List接口的实现类，所以他们中定义的方法基本上是一样的，因此只以其中一种举例。 调用Link集合方法的代码格式：123456789101112import java.util.ArrayList;//引用ArrayList包import java.util.List;//import java.util.LinkedList;//引用LinkedList包public class Test1 &#123; public static void main(String[] args) &#123;// LinkedList&lt;String&gt; names = new LinkedList&lt;String&gt;(); ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();&lt;String&gt;称之为泛型，用于限制集合中所能保存的数据类型，可等效为数组元素：String [] names = new String; .add()方法：作用：向集合中添加数据；格式：对象名.add（添加内容）；（添加内容必须与对象的类型一致）代码： 1234names.add(&quot;Tom&quot;);names.add(&quot;Tim&quot;);names.add(&quot;Tommy&quot;);names.add(&quot;aTom&quot;); .size()方法：作用：统计集合中有多少元素（元素可以重复储存）格式：对象名.size()；代码： 12int size = names.size();System.out.println(size); .isEmpty()方法：作用：判断集合中是否有元素，若有则返回true；若没有，则返回false格式：对象名.isEmpty();代码： 12boolean flag = names.isEmpty();// flag = falseSystem.out.println(flag); .clear()方法：作用：清空集合中的所有元素格式：对象名.clear()；代码： 123names.clear();//清空names的数据flag = names.isEmpty();//flag = true;System.out.println(flag); .get(index)方法：作用：获取对应位置index的数据，用法与数组相似，从零开始计数。格式：变量名 = 对象名.get（目标值位置）；代码： 12String name1 = names.get(0);System.out.println(name1); .add(index, element)方法作用：在指定位置index添加数据element，并且从index开始的所有元素以此后移，格式：对象名.add(index, element)代码： 12list.add(&quot;Tom&quot;);list.add(0，&quot;Jack&quot;); .set(index, element)方法作用：在指定位置index的数据替换为element格式：.set(index, element)；代码： 1list.set(0, &quot;JIM&quot;); 遍历集合中的元素：方法一：利用 .get(index) 方法实现传统数组输出方法：123for(int i = 0 ;i &lt; names.size() ;++i)&#123; System.out.println(names.get(i));&#125; 方法二：使用简便方法遍历：123for(String name : names) &#123; System.out.println(name);&#125; 方法三：借用Iterator包中的方法.hasNext()方法：作用：判断下一位是否有元素，即是否还有元素未被遍历出。格式：对象名.hasNext()；.next()方法：作用：调用除集合中的元素。格式：（变量=）对象名.next()； 1234Iterator&lt;String&gt; iterator = list.iterator();while(iterator.hasNext()) &#123; System.out.println(iterator.next());&#125; 总体代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.Iterator;import java.util.List;//import java.util.LinkedList;public class Test1 &#123; public static void main(String[] args) &#123; // LinkedList&lt;String&gt; names = new LinkedList&lt;String&gt;();// names.add(&quot;Tom&quot;);// names.add(&quot;Tim&quot;);// names.add(&quot;Tommy&quot;);// names.add(&quot;aTom&quot;); ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;(); names.add(&quot;Tom&quot;); names.add(&quot;Tim&quot;); names.add(&quot;Tommy&quot;); names.add(&quot;aTom&quot;); int size = names.size(); System.out.println(size); boolean flag = names.isEmpty(); System.out.println(flag); //names.clear();//清空names的数据 flag = names.isEmpty(); System.out.println(flag); String name1 = names.get(0); System.out.println(name1); for(String name : names) &#123; System.out.println(name); &#125; System.out.println(&quot;##################&quot;); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;Tom&quot;); list.add(&quot;Jack&quot;); list.add(0, &quot;Bob&quot;); list.set(0, &quot;JIM&quot;); Iterator&lt;String&gt; iterator = list.iterator(); while(iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125;","categories":[{"name":"集合","slug":"集合","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"面向对象和面向过程的区别","slug":"面向对象和面向过程的区别","date":"2021-10-08T16:00:00.000Z","updated":"2021-10-09T17:22:25.152Z","comments":true,"path":"2021/10/09/面向对象和面向过程的区别/","link":"","permalink":"http://example.com/2021/10/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一.面向过程与面向对象对比​ 面向过程：强调的是每一个功能的步骤，有很多很多方法组成，这些方法相互调用，完成需求。​ 面向对象：强调的是对象，然后由对象去调用功能。 ​ 面向过程：如果做小的项目，则效率非常高，很快就能实现，但是后期维护非常麻烦。 面向对象：如果做大的项目，则效率相对会低，但是代码结构性很好，后期维护容易。从这个方面来说，效率反而提高了。 二.以面向对象为主，对比面向过程说明面向对象的思想特点示例：把大象装进冰箱 面向过程： 分三步： ​ 1.打开冰箱门 ​ 2.装进大象 ​ 3.关闭冰箱门 代码示例： 1234567891011121314151617181920212223242526272829class Demo &#123; public static void main(String[] args) &#123; /* System.out.println(&quot;打开冰箱门&quot;); //打开冰箱门的动作，现在仅仅是为了演示，就写了一个输出语句，其实，它可能需要做很多操作。这个时候代码就比较多一些了。 //假设我要多次打开冰箱门，代码一多，每次都写一遍，麻烦不？ //我们就应该用方法改进。 System.out.println(&quot;装进大象&quot;); System.out.println(&quot;关闭冰箱门&quot;); */ //写了方法以后，调用就改变了。 open(); in(); close(); public static void open() &#123; System.out.println(&quot;打开冰箱门&quot;);&#125; public static void in() &#123; System.out.println(&quot;装进大象&quot;);&#125;public static void close() &#123; System.out.println(&quot;关闭冰箱门&quot;);&#125;&#125; 面向对象： ​ 我们怎么才能更符合面向对象思想呢？ 1:有哪些类呢？ 2:每个类有哪些东西呢？ 3:类与类之间的关系是什么呢？ 把大象装进冰箱的分析？(如何分析有哪些类呢？答：名词提取法) A:有哪些类呢？ 大象类 冰箱类 Demo类 B:每个类有哪些东西呢？ 大象类： 进去 冰箱类： 开门 关门 Demo类: main方法 C:类与类之间的关系是什么呢？ Demo类中使用大象类和冰箱类的功能。 代码示例： 大象类（进去）： 12345class 大象 &#123; public static void in() &#123; System.out.println(&quot;装进大象&quot;); &#125;&#125; 冰箱类（开关门）： 1234567891011class 冰箱 &#123; public static void open() &#123; System.out.println(&quot;打开冰箱门&quot;); &#125; public static void close() &#123; System.out.println(&quot;关闭冰箱门&quot;);&#125;&#125; Demo类（main()调用大象类和冰箱类）： 123456789class Demo &#123; public static void main(String[] args) &#123; 冰箱.open();//冰箱类调用开门方法 大象.in();大象类调用进去方法 冰箱.close();冰箱类调用关门方法 &#125; &#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"学习日记（for循环增强）","slug":"学习日记（for循环增强）","date":"2021-10-06T16:00:00.000Z","updated":"2021-10-10T11:15:00.040Z","comments":true,"path":"2021/10/07/学习日记（for循环增强）/","link":"","permalink":"http://example.com/2021/10/07/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88for%E5%BE%AA%E7%8E%AF%E5%A2%9E%E5%BC%BA%EF%BC%89/","excerpt":"","text":"增强for循环：简化迭代器书写一、增强for循环的简单实例1234567891011public class Demo&#123; public static void main(String[] args)&#123; int arr[] = &#123;1,2,3&#125;; /** *增强for */ for(int num : arr)&#123; System.out.println(num); &#125; &#125;&#125; 二、增强for循环的几种应用场景12345678910111213import java.util.ArrayList;import java.util.List;/** *增强for */public class Demo&#123;//数组的简单应用 public void test1()&#123; int arr[] = &#123;1,2,3&#125;; for(int num : arr)&#123; System.out.println(num); &#125; &#125; 1234567891011//链表的简单应用 public void test2()&#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); for(Object obj : list)&#123; int i = (Integer)obj; System.out.println(i); &#125; &#125; 12345678910111213141516//map的应用实例 //传统方式1 public void test3()&#123; Map map = new LinkedHashMap();//不同于HashMap的无顺序形式 map.put(&quot;1&quot;,&quot;aaa&quot;); map.put(&quot;2&quot;,&quot;bbb&quot;); map.put(&quot;3&quot;,&quot;ccc&quot;); Set set = map.keySet(); Iterator it = set.iterator(); while(it.hasNext())&#123; String key = (String)it.next(); String value = (String)map.get(key); System.out.println(key + &quot;=&quot; + value); &#125; &#125; 12345678910111213141516//传统方式2public void test4()&#123; Map map = new LinkedHashMap(); map.put(&quot;1&quot;,&quot;aaa&quot;); map.put(&quot;2&quot;,&quot;bbb&quot;); map.put(&quot;3&quot;,&quot;ccc&quot;); Set set = map.entrySet(); Iterator it = set.iterator(); while(it.hasNext())&#123; Map.Entry entry = (Entry)it.next(); String key = (String)entry.getKey(); String value = (String)entry.getValue(); System.out.println(key + &quot;=&quot; + value); &#125;&#125; 12345678910111213//增强for循环应用于map的第一种方法public void test5()&#123; Map map = new LinkedHashMap(); map.put(&quot;1&quot;,&quot;aaa&quot;); map.put(&quot;2&quot;,&quot;bbb&quot;); map.put(&quot;3&quot;,&quot;ccc&quot;); for(Object obj : map.keySet())&#123; String key = (String) obj; Stringg value = (String) map.get(key); System.out.println(key + &quot;=&quot; + value); &#125;&#125; 123456789101112131415 //增强for循环应用于map的第二种方法 public void test5()&#123; Map map = new LinkedHashMap(); map.put(&quot;1&quot;,&quot;aaa&quot;); map.put(&quot;2&quot;,&quot;bbb&quot;); map.put(&quot;3&quot;,&quot;ccc&quot;); for(Object obj : map.entrySet())&#123; Map.Entry entry = (entry) obj; String key = (String) entry.getKey(); Stringg value = (String) entry.getVnalue(); System.out.println(key + &quot;=&quot; + value); &#125; &#125;&#125; 三、增强for循环需要注意的问题1.只适合取数据，不能更改数据； 2.只用于数组，或实现Iterable接口的集合类上；set，list。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"面试内容总结","slug":"面试内容总结","date":"2021-10-04T16:00:00.000Z","updated":"2021-10-09T17:22:48.513Z","comments":true,"path":"2021/10/05/面试内容总结/","link":"","permalink":"http://example.com/2021/10/05/%E9%9D%A2%E8%AF%95%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"面试题01请你自我介绍一下你自己： 回答提示： 1、一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有，其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以 2、和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”。企业喜欢有礼貌的求职者。 范例; 考官好，我是计算机专业的面试者xxx，我此次应聘的职位是IT行业的软件工程师，这份工作不仅与我的专业对口，同时也是我的特长与兴趣所在。现在我就从以下三个方面介绍自己： ​ 1)学习能力：我有较强的科研能力，能熟练的使用‘eclipse’、‘idea’等编程相关软件，熟练并掌握MySQL数据库、Spring Boot框架等。 ​ 2)实践能力：我的专长是软件开发，我希望能从事这方面的工作经验，并且我曾经发过多个系统，如人事档案管理系统,工资管理系统等等。 ​ 3)交际能力：我的性格沉稳，能坐得住，对IT行业的工作，具有非常好的适应能力，而且为人谦和，具有很强的组织和协调能力 ，富有的事业心和责任感使我能够面对任何困难和挑战。 从以上的简单自我介绍，我希望公司能给我一个展示自己能力的机会，让我我可以学以致用，同时我也很欣赏XX公司的企业文化与工作环境。我愿意成为企业一员，为企业的发展贡献自己的一份力量。 我的职业生涯目标是，做一个既懂技术，又懂业务的复合型人才。","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]}],"categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"},{"name":"JavaWeb基础","slug":"JavaWeb基础","permalink":"http://example.com/categories/JavaWeb%E5%9F%BA%E7%A1%80/"},{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/"},{"name":"IO流","slug":"IO流","permalink":"http://example.com/categories/IO%E6%B5%81/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"五月天","slug":"五月天","permalink":"http://example.com/tags/%E4%BA%94%E6%9C%88%E5%A4%A9/"},{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"},{"name":"JavaWeb基础","slug":"JavaWeb基础","permalink":"http://example.com/tags/JavaWeb%E5%9F%BA%E7%A1%80/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]}