{"meta":{"title":1024,"subtitle":"与你，与我","description":"只有时时刻刻为将要到来的机会做准备，才不会错过那一次次的机会……","author":"feng","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-10-09T17:16:47.000Z","updated":"2021-10-09T17:17:37.741Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-09T12:35:25.000Z","updated":"2021-10-09T12:36:54.946Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2021-10-08T16:00:00.000Z","updated":"2021-12-03T09:44:03.618Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"武汉商学院 机器人工程专业 练习生一枚 IT 🐶 &amp; 半个Program 🐵 熟悉Java服务器端开发的知识 对分布式和微服务方向很感兴趣 经常参加有氧运动 喜欢看一些拓展思维的电影"},{"title":"weixin","date":"2021-10-09T09:33:03.000Z","updated":"2021-10-09T09:39:54.004Z","comments":true,"path":"weixin/index.html","permalink":"http://example.com/weixin/index.html","excerpt":"","text":"![](C:\\Users\\11419\\Desktop\\Study BOKE\\program\\blog\\source\\weixin\\111.jpg)"},{"title":"我的学习记录day01","date":"2021-10-06T05:49:46.000Z","updated":"2021-10-06T05:56:30.235Z","comments":true,"path":"我的学习记录day01/index.html","permalink":"http://example.com/%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95day01/index.html","excerpt":"","text":"HashMap集合嵌套ArrayList集合(如有侵权，请联系qq:1141973834 删除，此仅记录每天所学内容) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.Set;/** * @program: javalearnCode * @description: HashMap集合嵌套ArrayList集合。 * @author: chen * @create: 2018-09-03 11:34 **/ public class HashMapArrayListDemo &#123; public static void main(String[] args)&#123; /* 假设HashMap有3个集合是ArrayList： 三国演义 诸葛亮 周瑜 红楼梦 黛玉 宝玉 西游记 悟空 唐僧 */ //创建集合 HashMap&lt;String, ArrayList&lt;String&gt;&gt; novels= new HashMap&lt;String, ArrayList&lt;String&gt;&gt;(); ArrayList&lt;String&gt; sanGuoCharacters= new ArrayList&lt;String&gt;(); sanGuoCharacters.add(&quot;诸葛亮&quot;); sanGuoCharacters.add(&quot;周瑜&quot;); ArrayList&lt;String&gt; xiyoujiCharacters= new ArrayList&lt;String&gt;(); xiyoujiCharacters.add(&quot;悟空&quot;); xiyoujiCharacters.add(&quot;唐僧&quot;); ArrayList&lt;String&gt; hongloumengCharacters= new ArrayList&lt;String&gt;(); hongloumengCharacters.add(&quot;黛玉&quot;); hongloumengCharacters.add(&quot;宝玉&quot;); novels.put(&quot;三国演义&quot;, sanGuoCharacters); novels.put(&quot;西游记&quot;, xiyoujiCharacters); novels.put(&quot;红楼梦&quot;, hongloumengCharacters); //遍历 Set&lt;String&gt; keys= novels.keySet(); for(String key: keys)&#123; System.out.println(key); ArrayList&lt;String&gt; characters=novels.get(key); //遍历集合，List特有的遍历方式size()和get()结合 for(int i=0; i&lt;characters.size(); ++i)&#123; String character= characters.get(i); System.out.println(&#x27;\\t&#x27;+character); &#125; // 增强for遍历集合 // for(String character: characters)&#123; // System.out.println(character); // &#125;// 迭代器遍历集合// Iterator&lt;String&gt; it= characters.iterator();// while(it.hasNext())&#123;// String character= it.next();// System.out.println(character);// &#125; &#125; &#125;&#125; ArrayList集合嵌套HashMap集合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.ArrayList;import java.util.HashMap;import java.util.Set;/** * @program: javalearnCode * @description: ArrayList集合嵌套HashMap * @author: chen * @create: 2018-09-03 16:29 **/public class ArraListHashMapDemo &#123; public static void main(String[] args)&#123; //假设ArrayList有3个集合是HashMap /* 吕布-貂蝉 周瑜-小乔 --------------- 牛魔王-铁扇公主 玉帝-王母 --------------- 贾琏-王熙凤 贾宝玉-薛宝钗 --------------- */ //创建集合 ArrayList&lt;HashMap&lt;String, String&gt;&gt; array= new ArrayList&lt;HashMap&lt;String, String&gt;&gt;(); HashMap&lt;String, String&gt; sanguoCouples= new HashMap&lt;String, String&gt;(); sanguoCouples.put(&quot;周瑜&quot;,&quot;小乔&quot;); sanguoCouples.put(&quot;吕布&quot;,&quot;貂蝉&quot;); HashMap&lt;String,String&gt; xiyoujiCouples= new HashMap&lt;String, String&gt;(); xiyoujiCouples.put(&quot;牛魔王&quot;,&quot;铁扇公主&quot;); xiyoujiCouples.put(&quot;玉帝&quot;,&quot;王母&quot;); HashMap&lt;String, String&gt; hongloumengCouples= new HashMap&lt;String, String&gt;(); hongloumengCouples.put(&quot;贾琏&quot;,&quot;王熙凤&quot;); hongloumengCouples.put(&quot;贾宝玉&quot;,&quot;薛宝钗&quot;); array.add(sanguoCouples); array.add(xiyoujiCouples); array.add(hongloumengCouples); //遍历集合 //获取ArrayList集合中每个HashMap元素 for(HashMap&lt;String, String&gt; couples: array)&#123; //先获取所有键 Set&lt;String&gt; husbands=couples.keySet(); for(String husband: husbands)&#123; //根据键获取值 String wife= couples.get(husband); System.out.println(husband+&quot;-&quot;+wife); &#125; System.out.println(&quot;---------------&quot;); &#125; &#125;&#125;"}],"posts":[{"title":"Redis","slug":"Redis","date":"2022-03-28T16:00:00.000Z","updated":"2022-04-13T13:19:17.158Z","comments":true,"path":"2022/03/29/Redis/","link":"","permalink":"http://example.com/2022/03/29/Redis/","excerpt":"","text":"Redis学习笔记1.Redis的安装 下载安装包 将本地安装包上传到服务器（Linux） 安装gcc的C语言编译环境 解压服务器端的Redis压缩包 编译解压后的文件 安装编译后的文件 1.首先在官网下载redis 的安装包（linux系统的安装包）Download | Redis 2.将Linux压缩包传到Linux系统中1234上传命令：scp /redis/redis-6.2.6.tar.gz root@119.91.204.71:/redis/// /redis/redis-6.2.6.tar.gz --本地安装包目录// /redis/ --需要传到的Linux系统目录// root@119.91.204.71: --服务器用户名@服务器地址 出现错误：Permission denied, please try again. 出现原因：上传的文件夹没有权限 解决方法：chmod 776 /redis/ –开放文件夹的读写权限 Linux实用命令：Linux常用实用命令-格姗知识圈 (geshanzsq.com) 123456789101112131415Linux 下的每个文件都有以下三种权限r：表示读取，对应的数字为 4；w：表示写入，对应的数字为 2；x：表示执行，对应的数字为 1通过 4、2、1 的组合，我们可以得到以下几种权限0：没有权限，用 - 表示4：读取权限，用 w 表示5：读取和执行权限，用 rx 表示6：读取和写入权限，用 rw 表示7：读取、写入和执行权限，用 rwx 表示 3.安装gcc的C语言编译环境1234//安装gccinstall gcc//查看版本号gcc --version 4.解压压缩包1tar -zxvf redis-6.2.6.tar.gz 5.编译解压后的文件==这一步只是编译了文件，并没有进行安装== 1234//进入解压后的文件目录redis-6.2.6cd redis-6.2.6//编译make 可能报错: 解决方法：make distclean 后重新编译 6.安装编译后的redis文件123456//安装redismake install//查看安装的文件（一般会安装在 /usr/local/bin）cd /usr/local/bin//查看ls||ll 7.启动redis 前台启动（不推荐） ==需要在bin目录下执行== 1redis-server 后台启动（推荐） 1.复制 redis-6.2.6目录下的redis.conf文件 12//复制 redis.conf文件到copy_redis目录下取名redis.confcp redis.conf /copy_redis/redis.conf 2.使用vi编辑器修改指令 123456789//进入copy——redis的文件夹cd /copy_redis//使用vi编辑器进入redis.confvi redis.conf--&gt; 命令模式下使用 /daemonize寻找关键字--&gt; 按a进入insert模式--&gt; 将daemonize no ---&gt; daemonize yes--&gt; 按ESC退出编辑模式--&gt; 输入 :wq 保存并退出 3.启动后台redis 与关闭 12345678910//进入/usr/local/bin目录cd /usr/local/bin//启动redisredis-server /copy_redis/redis.conf//查看redis进程ps -ef | grep redis//访问redisredis-cli//关闭redisredis-cli shutdown || kill -9 进程号（如图） || redis-cli -p63 2.redis.conf配置文件的修改1234// 修改/copy_redis中的redis.confcd /copy_redis// 使用vi编辑器进入redis.confvi redis.conf ==注销 bind 127.0.0.1 -::1== 不改只能本地访问 ==将protected-mode yes —&gt; protected-mode no== 改成no支持远程访问 修改密码 1234//找到如下内容#requirepass foobared//去掉注释或另起一行；设置密码requirepass 123456qq 验证密码 12345678910111213141516171. 启动： ./redis-server redis.conf 2. 进入客户端： ./redis-cli 3. 输入config get requirepass验证4. 出现“(error) NOAUTH Authentication required.证明设置密码成功！5. 输入密码： auth 123456qq 得到ok6. 再次输入config get requirepass验证，即可看到自己设置的密码，123456就是密码 1) &quot;requirepass&quot; 2) &quot;123456qq&quot; 3.Jedis操作Redis 注释redis.conf中的bind 127.0.0.1 //不注释只能本地访问 将protected-mode yes —&gt; protected-mode no //开启远程的访问 关闭防火墙或者开启安全组的端口端口权限 123456789101112131415161、开启防火墙 systemctl start firewalld2、查看防火墙状态systemctl status firewalld3、关闭防火墙 systemctl stop firewalld4、开放指定端口firewall-cmd --zone=public --add-port=1935/tcp --permanent命令含义：--zone #作用域--add-port=1935/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效5、查看端口号netstat -ntlp //查看当前所有tcp端口·netstat -ntulp |grep 1935 //查看所有1935端口使用情况·","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"}]},{"title":"玫瑰少年","slug":"玫瑰少年","date":"2022-03-18T16:00:00.000Z","updated":"2022-03-19T05:56:07.470Z","comments":true,"path":"2022/03/19/玫瑰少年/","link":"","permalink":"http://example.com/2022/03/19/%E7%8E%AB%E7%91%B0%E5%B0%91%E5%B9%B4/","excerpt":"","text":"玫瑰少年- 五月天谁把谁的灵魂 装进谁的身体谁把谁的身体 变成囹圄囚禁自己乱世总是最 不缺耳语哪种美丽会 换来妒忌你并没有罪 有罪是这世界生而为人无罪 你不需要抱歉ONE day I wIll be you baby boy and you Gon’be me喧哗如果不停 让我陪你安静I wIsh I could hug you tIll you’re really really being free哪朵玫瑰没有荆棘最好的 报复是 美丽最美的 盛开是 反击别让谁去 改变了你你是你 或是妳 都行会有人 全心的 爱你试着想像 you swItched to hIs bodySeXualIty 当心什么会伤你多少次的重伤 多少次的冷语Drowning 谁会拉你Dreaming 谁会陪你Same s**t happens every day你离开后 世界可改变多少无知罪愆 事过不境迁永志不忘纪念 往事不如烟生而为人无罪 你不需要抱歉ONE day I wIll be you baby boy and you Gon’be me喧哗如果不停 让我陪你安静I wIsh I could hug you tIll you’re really really being free哪朵玫瑰没有荆棘最好的 报复是 美丽最美的 盛开是 反击别让谁去 改变了你你是你 或是妳 都行会有人 全心的 爱你玫瑰少年 在我心里绽放着 鲜艳的 传奇我们都 从来没 忘记你的控诉 没有声音却倾诉 更多的 真理却唤醒 无数的 真心哪朵玫瑰没有荆棘最好的 报复是 美丽最美的 盛开是 反击别让谁去 改变了你你是你 或是妳 都行会有人 全心的 爱你玫瑰少年 在我心里玫瑰少年 在我心里","categories":[],"tags":[{"name":"五月天","slug":"五月天","permalink":"http://example.com/tags/%E4%BA%94%E6%9C%88%E5%A4%A9/"}]},{"title":"JavaSE知识体系","slug":"JavaSE知识体系","date":"2021-12-10T16:00:00.000Z","updated":"2022-04-04T15:10:50.694Z","comments":true,"path":"2021/12/11/JavaSE知识体系/","link":"","permalink":"http://example.com/2021/12/11/JavaSE%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","excerpt":"","text":"JavaSE知识梳理2. 数据类型2.1 基本类型 数据类型 包装类 所占字节 boolean Boolean 未定 byte Byte 1字节 char Character 2字节 short Short 2字节 int Integer 4字节 float Float 4字节 long Long 8字节 double Double 8字节 2.2 其它类型 2.3 类型转换 小类型自动转换为大类型 3. 运算符3.1 赋值运算符 3.2 算数运算符 3.3 关系运算符 3.4 位运算符 3.5 运算符优先级 运算符优先级常规掌握就好，在开发中通常使用括号明确运算的优先级关系 3.6 问题思考 4. 程序三大逻辑结构4.1 顺序从上到下 4.2 分支 4.3 循环 5. 数组5.1 知识点 5.2 技术问题 5.3 Arrays常用函数5.3.1 Arrays.sort(int[] a,int fromIndex,int toIndex) Arrays.sort()只能给int[] 形的数组排序，不能给动态数组ArrayList排序。 Arrays.sort()按升序排序，要按降序排序的话还挺麻烦的。 void Arrays.sort(int[] a) –&gt; 将数组a升序排序 void Arrays.sort(int[] a,int fromIndex,int toIndex) –&gt; 将fromIndex与toIndex之间的元素进行排序(备注：fromIndex（起始索引），toIndex（终点索引）) 12345int[] b=&#123;1,5,9,8,6,3,7,4,2,10&#125;;Arrays.sort(b,5,9);for(int i:b)&#123; System.out.print(i+&quot; &quot;);&#125; 1输出：1 5 9 8 6 2 3 4 7 10 1解释：从5号索引到9号索引，即3、7、4、2、10 --&gt; 2、3、4、7、10 5.3.2 Arrays.fill() 用于给数组填充数字 12int[] nums=new int[5];Arrays.fill(nums, 6); 5.3.3 Arrays.equals() 用于对比两数组中的元素是否一样 123int[] nums1=&#123;2,6,8,1&#125;;int[] nums2=&#123;2,6,8,1&#125;;Arrays.equals(nums1,nums2); // true 5.3.4 Arrays.toString() 将数组转为字符串表示出来 123Character[] chars= &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;System.out.print(Arrays.toString(chars));// [a, b, c] 5.3.5Arrays.binarySearch() 判断数组中是否有某个元素，有的话返回该元素的坐标，否则返回-1 123int[] nums= &#123;3,6,8,5,1&#125;;System.out.println(Arrays.binarySearch(nums, 3)); // 0System.out.println(Arrays.binarySearch(nums, 0)); // -1","categories":[],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"}]},{"title":"JavaWeb基础知识","slug":"JavaWeb基础知识","date":"2021-10-23T16:00:00.000Z","updated":"2021-10-24T13:36:04.195Z","comments":true,"path":"2021/10/24/JavaWeb基础知识/","link":"","permalink":"http://example.com/2021/10/24/JavaWeb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Junit12345678910111213141516171819202122232425262728293031* 测试分类： 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 2. 白盒测试：需要写代码的。关注程序具体的执行流程。* Junit使用：白盒测试 * 步骤： 1. 定义一个测试类(测试用例) * 建议： * 测试类名：被测试的类名Test CalculatorTest * 包名：xxx.xxx.xx.test cn.itcast.test 2. 定义测试方法：可以独立运行 * 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 3. 给方法加@Test 4. 导入junit依赖环境 * 判定结果： * 红色：失败 * 绿色：成功 * 一般我们会使用断言操作来处理结果 * Assert.assertEquals(期望的结果,运算的结果); * 补充： * @Before: * 修饰的方法会在测试方法之前被自动执行 * @After: * 修饰的方法会在测试方法执行之后自动被执行","categories":[{"name":"JavaWeb基础","slug":"JavaWeb基础","permalink":"http://example.com/categories/JavaWeb%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JavaWeb基础","slug":"JavaWeb基础","permalink":"http://example.com/tags/JavaWeb%E5%9F%BA%E7%A1%80/"}]},{"title":"知识辨析","slug":"知识辨析","date":"2021-10-21T16:00:00.000Z","updated":"2022-03-19T05:49:04.327Z","comments":true,"path":"2021/10/22/知识辨析/","link":"","permalink":"http://example.com/2021/10/22/%E7%9F%A5%E8%AF%86%E8%BE%A8%E6%9E%90/","excerpt":"","text":"== 与 equals(重要)== : 它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型==⽐较的是值，引⽤数据类型==⽐较的是内存地址)。 equals:它的作⽤也是判断两个对象是否相等。但它⼀般有两种使⽤情况：情况 1：类没有覆盖 equals() ⽅法。则通过 equals() ⽐᫾该类的两个对象时，等价于通过“==”⽐较这两个对象。 情况 2：类覆盖了 equals() ⽅法。⼀般，我们都覆盖 equals() ⽅法来⽐᫾两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 说明: String 中的 equals ⽅法是被重写过的，因为 object 的 equals ⽅法是⽐᫾的对象的内存地 址，⽽ String 的 equals ⽅法⽐᫾的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相 同的对象，如果有就把它赋给当前引⽤。如果没有就在常量池中重新创建⼀个 String 对象。","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java基础问题合集","slug":"Java基础问题合集","date":"2021-10-16T16:00:00.000Z","updated":"2021-10-17T15:17:56.163Z","comments":true,"path":"2021/10/17/Java基础问题合集/","link":"","permalink":"http://example.com/2021/10/17/Java%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/","excerpt":"","text":"问题合集：什么是泛型？ 答：泛型：即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。泛型的本质：是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 Collection(Set List)Set的接口继承Collection接口，而且不允许集合中存在重复项。 List接口继承了Collection接口以定义一个允许重复项的有序集合。 Set：搜索元素效率低下，删除和插入的效率高，插入和删除不会引起元素的位置变化。 List：和数组类似，List可以动态增长，查找元素的效率较高，插入元素和删除元素效率低，因为会引起其他元素位置发生变化。 Set 和 List的具体子类： Set ----HashSet：以哈希表的形式存放元素，插入删除速度很快 List： ----ArrayList :动态数组 ----LinkedList:链表，队列，堆栈","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java集合详解","slug":"Java集合详解","date":"2021-10-11T04:13:35.000Z","updated":"2021-10-11T04:53:00.279Z","comments":true,"path":"2021/10/11/Java集合详解/","link":"","permalink":"http://example.com/2021/10/11/Java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"表 1 Java集合接口的作用 接口名称 作 用 Iterator 接口 集合的输出接口，主要用于遍历输出（即迭代访问）Collection 集合中的元素，Iterator 对象被称之为迭代器。迭代器接口是集合接口的父接口，实现类实现 Collection 时就必须实现 Iterator 接口。 Collection 接口 是 List、Set 和 Queue 的父接口，是存放一组单值的最大接口。所谓的单值是指集合中的每个元素都是一个对象。一般很少直接使用此接口直接操作。 Queue 接口 Queue 是 Java 提供的队列实现，有点类似于 List。 Dueue 接口 是 Queue 的一个子接口，为双向队列。 List 接口 是最常用的接口。是有序集合，允许有相同的元素。使用 List 能够精确地控制每个元素插入的位置，用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，与数组类似。 Set 接口 不能包含重复的元素。 Map 接口 是存放一对值的最大接口，即接口中的每个元素都是一对，以 key➡value 的形式保存。 ​ 对于 Set、List、Queue 和 Map 这 4 种集合，Java 最常用的实现类分别是 HashSet、TreeSet、ArrayList、ArrayDueue、LinkedList 和 HashMap、TreeMap 等。表 2 介绍了集合中这些常用的实现类。 表 2 Java集合实现类的作用 类名称 作用 HashSet 为优化査询速度而设计的 Set。它是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，实现比较简单 TreeSet 实现了 Set 接口，是一个有序的 Set，这样就能从 Set 里面提取一个有序序列 ArrayList 一个用数组实现的 List，能进行快速的随机访问，效率高而且实现了可变大小的数组 ArrayDueue 是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素 LinkedList 对顺序访问进行了优化，但随机访问的速度相对较慢。此外它还有 addFirst()、addLast()、getFirst()、getLast()、removeFirst() 和 removeLast() 等方法，能把它当成栈（Stack）或队列（Queue）来用 HsahMap 按哈希算法来存取键对象 TreeMap 可以对键对象进行排序","categories":[{"name":"集合","slug":"集合","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"字节流和字符流的用法","slug":"字节流和字符流的用法","date":"2021-10-10T16:00:00.000Z","updated":"2021-10-11T10:36:04.895Z","comments":true,"path":"2021/10/11/字节流和字符流的用法/","link":"","permalink":"http://example.com/2021/10/11/%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E7%94%A8%E6%B3%95/","excerpt":"","text":"字节流作用:字节流可以将文字图片音频等等文件转成字节进行数据传输分为:OutputStream: 输出流,写文件InputStream: 输入流,读文件 输出流的使用实例:12345678910111213141516// 创建一个字节输出流,写文件,设置文件路径,如果没有,系统会自动创建FileOutputStream fos = new FileOutputStream(&quot;Desktop/d.txt&quot;);// 写入方法write// 该方法是按ASCII码写入的fos.write(65);// 利用字节数组写入,同样是按ASCII码写入[A(65),B,C,D,E(69)]byte[] b = &#123;66,67,68,69&#125;;fos.write(b);// 将&quot;hello&quot; 转成字节数组写fos.write(&quot;hello&quot;.getBytes());// 按偏移量写入数组的字符,b代表数组名,1代表数组角标(数组索引值),2代表长度fos.write(b, 1, 2);// 关闭资源 fos.close(); 注意:写完要关闭资源,一般会判断一下,创建流时有可能发生异常,利用finally特性补充一下判断123456789finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(&quot;关闭失败&quot;); &#125; &#125; &#125; 输入流用来读取文件,有三种方法 单个读取 1234567891011// 设置读取路径FileInputStream fis = new FileInputStream(&quot;Desktop/heihei.txt&quot;);// fis.read读取int by = fis.read();// 转为字符输出,不然输出的ASCII的对应值System.out.println((char)by);// 继续读取by = fis.read();System.out.println((char)by);// 关闭资源fis.close(); 注意:当文件读取完毕时,返回值为-1 循环读取 1234567FileInputStream fis = new FileInputStream(&quot;Desktop/heihei.txt&quot;);int by = 0;//fis.read()为-1时,文件读取完毕while ((by = fis.read()) != -1) &#123; System.out.println((char)by); &#125; fis.close(); 利用字节数组读取 12345678910111213 FileInputStream fis = new FileInputStream(&quot;Desktop/heihei.txt&quot;);// 创建数组,数组长度一般为1024的倍数byte[] b = new byte[1024];// 接收有效长度int len = 0;// fis.read(b)返回值是有效长度 while ((len = fis.read(b)) != -1) &#123;// 使用字符串的构造方法打印 System.out.println(new String(b, 0, len));&#125;fis.close(); 字符流分为:FileWriter: 写入文件FileReader: 读取文件 输出流使用方法​ 123456789101112131415161718// 创建字符输出流FileWriter fw = new FileWriter(&quot;Desktop/hh.txt&quot;);// 写入文件fw.write(65);// 刷新(会将内容写入到文件中,如果不刷新,将不会写入)fw.flush(); // 字符数组写入char[] c =&#123;&#x27;7&#x27;,&#x27;8&#x27;&#125;;fw.write(c);fw.flush();// 字符串直接写入// 换行 \\n (mac系统) \\r\\n(windows) \\n(Linux)fw.write(&quot;我的\\n&quot;);fw.write(&quot;世界\\n&quot;);fw.flush(); // 关闭资源// 关闭前,系统自动刷新fw.close(); 输入流读取文件使用,同样三种方法(与字节流基本相同) 单个读取 12345678910// 设置读取路径FileReader fr = new FileReader(&quot;Desktop/heihei.txt&quot;);int num = fr.read();System.out.println((char)num);// 继续读取num = fr.read();// 强转为字符输出System.out.println((char)num);// 关闭资源fr.close(); 循环读取 12345678// 设置读取路径FileReader fr = new FileReader(&quot;Desktop/heihei.txt&quot;);int num = 0;while ((num = fr.read()) != -1) &#123;// 强转为字符输出 System.out.print((char)num);&#125;fr.close(); 利用字符数组读取 1234567FileReader fr = new FileReader(&quot;Desktop/heihei.txt&quot;); char[] c = new char[1024]; int len = 0; while ((len = fr.read(c)) ! = -1) &#123; System.out.println(new String(c, 0, len)); &#125; fr.close();","categories":[{"name":"IO流","slug":"IO流","permalink":"http://example.com/categories/IO%E6%B5%81/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"List集合中方法总结","slug":"List集合中方法总结","date":"2021-10-10T14:53:42.000Z","updated":"2021-10-10T15:21:45.508Z","comments":true,"path":"2021/10/10/List集合中方法总结/","link":"","permalink":"http://example.com/2021/10/10/List%E9%9B%86%E5%90%88%E4%B8%AD%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"List集合常用方法由于List集合中的ArrayList与LinkedList都是List接口的实现类，所以他们中定义的方法基本上是一样的，因此只以其中一种举例。 调用Link集合方法的代码格式：123456789101112import java.util.ArrayList;//引用ArrayList包import java.util.List;//import java.util.LinkedList;//引用LinkedList包public class Test1 &#123; public static void main(String[] args) &#123;// LinkedList&lt;String&gt; names = new LinkedList&lt;String&gt;(); ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;();&lt;String&gt;称之为泛型，用于限制集合中所能保存的数据类型，可等效为数组元素：String [] names = new String; .add()方法：作用：向集合中添加数据；格式：对象名.add（添加内容）；（添加内容必须与对象的类型一致）代码： 1234names.add(&quot;Tom&quot;);names.add(&quot;Tim&quot;);names.add(&quot;Tommy&quot;);names.add(&quot;aTom&quot;); .size()方法：作用：统计集合中有多少元素（元素可以重复储存）格式：对象名.size()；代码： 12int size = names.size();System.out.println(size); .isEmpty()方法：作用：判断集合中是否有元素，若有则返回true；若没有，则返回false格式：对象名.isEmpty();代码： 12boolean flag = names.isEmpty();// flag = falseSystem.out.println(flag); .clear()方法：作用：清空集合中的所有元素格式：对象名.clear()；代码： 123names.clear();//清空names的数据flag = names.isEmpty();//flag = true;System.out.println(flag); .get(index)方法：作用：获取对应位置index的数据，用法与数组相似，从零开始计数。格式：变量名 = 对象名.get（目标值位置）；代码： 12String name1 = names.get(0);System.out.println(name1); .add(index, element)方法作用：在指定位置index添加数据element，并且从index开始的所有元素以此后移，格式：对象名.add(index, element)代码： 12list.add(&quot;Tom&quot;);list.add(0，&quot;Jack&quot;); .set(index, element)方法作用：在指定位置index的数据替换为element格式：.set(index, element)；代码： 1list.set(0, &quot;JIM&quot;); 遍历集合中的元素：方法一：利用 .get(index) 方法实现传统数组输出方法：123for(int i = 0 ;i &lt; names.size() ;++i)&#123; System.out.println(names.get(i));&#125; 方法二：使用简便方法遍历：123for(String name : names) &#123; System.out.println(name);&#125; 方法三：借用Iterator包中的方法.hasNext()方法：作用：判断下一位是否有元素，即是否还有元素未被遍历出。格式：对象名.hasNext()；.next()方法：作用：调用除集合中的元素。格式：（变量=）对象名.next()； 1234Iterator&lt;String&gt; iterator = list.iterator();while(iterator.hasNext()) &#123; System.out.println(iterator.next());&#125; 总体代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.Iterator;import java.util.List;//import java.util.LinkedList;public class Test1 &#123; public static void main(String[] args) &#123; // LinkedList&lt;String&gt; names = new LinkedList&lt;String&gt;();// names.add(&quot;Tom&quot;);// names.add(&quot;Tim&quot;);// names.add(&quot;Tommy&quot;);// names.add(&quot;aTom&quot;); ArrayList&lt;String&gt; names = new ArrayList&lt;String&gt;(); names.add(&quot;Tom&quot;); names.add(&quot;Tim&quot;); names.add(&quot;Tommy&quot;); names.add(&quot;aTom&quot;); int size = names.size(); System.out.println(size); boolean flag = names.isEmpty(); System.out.println(flag); //names.clear();//清空names的数据 flag = names.isEmpty(); System.out.println(flag); String name1 = names.get(0); System.out.println(name1); for(String name : names) &#123; System.out.println(name); &#125; System.out.println(&quot;##################&quot;); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;Tom&quot;); list.add(&quot;Jack&quot;); list.add(0, &quot;Bob&quot;); list.set(0, &quot;JIM&quot;); Iterator&lt;String&gt; iterator = list.iterator(); while(iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125;","categories":[{"name":"集合","slug":"集合","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"面向对象和面向过程的区别","slug":"面向对象和面向过程的区别","date":"2021-10-08T16:00:00.000Z","updated":"2021-10-09T17:22:25.152Z","comments":true,"path":"2021/10/09/面向对象和面向过程的区别/","link":"","permalink":"http://example.com/2021/10/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一.面向过程与面向对象对比​ 面向过程：强调的是每一个功能的步骤，有很多很多方法组成，这些方法相互调用，完成需求。​ 面向对象：强调的是对象，然后由对象去调用功能。 ​ 面向过程：如果做小的项目，则效率非常高，很快就能实现，但是后期维护非常麻烦。 面向对象：如果做大的项目，则效率相对会低，但是代码结构性很好，后期维护容易。从这个方面来说，效率反而提高了。 二.以面向对象为主，对比面向过程说明面向对象的思想特点示例：把大象装进冰箱 面向过程： 分三步： ​ 1.打开冰箱门 ​ 2.装进大象 ​ 3.关闭冰箱门 代码示例： 1234567891011121314151617181920212223242526272829class Demo &#123; public static void main(String[] args) &#123; /* System.out.println(&quot;打开冰箱门&quot;); //打开冰箱门的动作，现在仅仅是为了演示，就写了一个输出语句，其实，它可能需要做很多操作。这个时候代码就比较多一些了。 //假设我要多次打开冰箱门，代码一多，每次都写一遍，麻烦不？ //我们就应该用方法改进。 System.out.println(&quot;装进大象&quot;); System.out.println(&quot;关闭冰箱门&quot;); */ //写了方法以后，调用就改变了。 open(); in(); close(); public static void open() &#123; System.out.println(&quot;打开冰箱门&quot;);&#125; public static void in() &#123; System.out.println(&quot;装进大象&quot;);&#125;public static void close() &#123; System.out.println(&quot;关闭冰箱门&quot;);&#125;&#125; 面向对象： ​ 我们怎么才能更符合面向对象思想呢？ 1:有哪些类呢？ 2:每个类有哪些东西呢？ 3:类与类之间的关系是什么呢？ 把大象装进冰箱的分析？(如何分析有哪些类呢？答：名词提取法) A:有哪些类呢？ 大象类 冰箱类 Demo类 B:每个类有哪些东西呢？ 大象类： 进去 冰箱类： 开门 关门 Demo类: main方法 C:类与类之间的关系是什么呢？ Demo类中使用大象类和冰箱类的功能。 代码示例： 大象类（进去）： 12345class 大象 &#123; public static void in() &#123; System.out.println(&quot;装进大象&quot;); &#125;&#125; 冰箱类（开关门）： 1234567891011class 冰箱 &#123; public static void open() &#123; System.out.println(&quot;打开冰箱门&quot;); &#125; public static void close() &#123; System.out.println(&quot;关闭冰箱门&quot;);&#125;&#125; Demo类（main()调用大象类和冰箱类）： 123456789class Demo &#123; public static void main(String[] args) &#123; 冰箱.open();//冰箱类调用开门方法 大象.in();大象类调用进去方法 冰箱.close();冰箱类调用关门方法 &#125; &#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"学习日记（for循环增强）","slug":"学习日记（for循环增强）","date":"2021-10-06T16:00:00.000Z","updated":"2021-10-10T11:15:00.040Z","comments":true,"path":"2021/10/07/学习日记（for循环增强）/","link":"","permalink":"http://example.com/2021/10/07/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88for%E5%BE%AA%E7%8E%AF%E5%A2%9E%E5%BC%BA%EF%BC%89/","excerpt":"","text":"增强for循环：简化迭代器书写一、增强for循环的简单实例1234567891011public class Demo&#123; public static void main(String[] args)&#123; int arr[] = &#123;1,2,3&#125;; /** *增强for */ for(int num : arr)&#123; System.out.println(num); &#125; &#125;&#125; 二、增强for循环的几种应用场景12345678910111213import java.util.ArrayList;import java.util.List;/** *增强for */public class Demo&#123;//数组的简单应用 public void test1()&#123; int arr[] = &#123;1,2,3&#125;; for(int num : arr)&#123; System.out.println(num); &#125; &#125; 1234567891011//链表的简单应用 public void test2()&#123; List list = new ArrayList(); list.add(1); list.add(2); list.add(3); for(Object obj : list)&#123; int i = (Integer)obj; System.out.println(i); &#125; &#125; 12345678910111213141516//map的应用实例 //传统方式1 public void test3()&#123; Map map = new LinkedHashMap();//不同于HashMap的无顺序形式 map.put(&quot;1&quot;,&quot;aaa&quot;); map.put(&quot;2&quot;,&quot;bbb&quot;); map.put(&quot;3&quot;,&quot;ccc&quot;); Set set = map.keySet(); Iterator it = set.iterator(); while(it.hasNext())&#123; String key = (String)it.next(); String value = (String)map.get(key); System.out.println(key + &quot;=&quot; + value); &#125; &#125; 12345678910111213141516//传统方式2public void test4()&#123; Map map = new LinkedHashMap(); map.put(&quot;1&quot;,&quot;aaa&quot;); map.put(&quot;2&quot;,&quot;bbb&quot;); map.put(&quot;3&quot;,&quot;ccc&quot;); Set set = map.entrySet(); Iterator it = set.iterator(); while(it.hasNext())&#123; Map.Entry entry = (Entry)it.next(); String key = (String)entry.getKey(); String value = (String)entry.getValue(); System.out.println(key + &quot;=&quot; + value); &#125;&#125; 12345678910111213//增强for循环应用于map的第一种方法public void test5()&#123; Map map = new LinkedHashMap(); map.put(&quot;1&quot;,&quot;aaa&quot;); map.put(&quot;2&quot;,&quot;bbb&quot;); map.put(&quot;3&quot;,&quot;ccc&quot;); for(Object obj : map.keySet())&#123; String key = (String) obj; Stringg value = (String) map.get(key); System.out.println(key + &quot;=&quot; + value); &#125;&#125; 123456789101112131415 //增强for循环应用于map的第二种方法 public void test5()&#123; Map map = new LinkedHashMap(); map.put(&quot;1&quot;,&quot;aaa&quot;); map.put(&quot;2&quot;,&quot;bbb&quot;); map.put(&quot;3&quot;,&quot;ccc&quot;); for(Object obj : map.entrySet())&#123; Map.Entry entry = (entry) obj; String key = (String) entry.getKey(); Stringg value = (String) entry.getVnalue(); System.out.println(key + &quot;=&quot; + value); &#125; &#125;&#125; 三、增强for循环需要注意的问题1.只适合取数据，不能更改数据； 2.只用于数组，或实现Iterable接口的集合类上；set，list。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"面试内容总结","slug":"面试内容总结","date":"2021-10-04T16:00:00.000Z","updated":"2021-10-09T17:22:48.513Z","comments":true,"path":"2021/10/05/面试内容总结/","link":"","permalink":"http://example.com/2021/10/05/%E9%9D%A2%E8%AF%95%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"面试题01请你自我介绍一下你自己： 回答提示： 1、一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有，其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，这些都可以 2、和学习无关，也可以和学习有关，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，在回答每个问题之后都说一句“谢谢”。企业喜欢有礼貌的求职者。 范例; 考官好，我是计算机专业的面试者xxx，我此次应聘的职位是IT行业的软件工程师，这份工作不仅与我的专业对口，同时也是我的特长与兴趣所在。现在我就从以下三个方面介绍自己： ​ 1)学习能力：我有较强的科研能力，能熟练的使用‘eclipse’、‘idea’等编程相关软件，熟练并掌握MySQL数据库、Spring Boot框架等。 ​ 2)实践能力：我的专长是软件开发，我希望能从事这方面的工作经验，并且我曾经发过多个系统，如人事档案管理系统,工资管理系统等等。 ​ 3)交际能力：我的性格沉稳，能坐得住，对IT行业的工作，具有非常好的适应能力，而且为人谦和，具有很强的组织和协调能力 ，富有的事业心和责任感使我能够面对任何困难和挑战。 从以上的简单自我介绍，我希望公司能给我一个展示自己能力的机会，让我我可以学以致用，同时我也很欣赏XX公司的企业文化与工作环境。我愿意成为企业一员，为企业的发展贡献自己的一份力量。 我的职业生涯目标是，做一个既懂技术，又懂业务的复合型人才。","categories":[{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]}],"categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"},{"name":"JavaWeb基础","slug":"JavaWeb基础","permalink":"http://example.com/categories/JavaWeb%E5%9F%BA%E7%A1%80/"},{"name":"面试","slug":"面试","permalink":"http://example.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"集合","slug":"集合","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/"},{"name":"IO流","slug":"IO流","permalink":"http://example.com/categories/IO%E6%B5%81/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/tags/Redis/"},{"name":"五月天","slug":"五月天","permalink":"http://example.com/tags/%E4%BA%94%E6%9C%88%E5%A4%A9/"},{"name":"JavaSE","slug":"JavaSE","permalink":"http://example.com/tags/JavaSE/"},{"name":"JavaWeb基础","slug":"JavaWeb基础","permalink":"http://example.com/tags/JavaWeb%E5%9F%BA%E7%A1%80/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]}